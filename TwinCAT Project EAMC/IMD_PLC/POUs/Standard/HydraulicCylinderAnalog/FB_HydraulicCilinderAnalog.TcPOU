<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.16">
  <POU Name="FB_HydraulicCilinderAnalog" Id="{f656e3fc-b3ed-42d3-a4ef-1eb76193e145}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_HydraulicCilinderAnalog
VAR_INPUT
	///Reset Error
	mxReset: BOOL;
	mxEmergency: BOOL;
	/// TRUE = Automode 
	mxAutoMode: BOOL;
	EndPositionIn: REAL;
	EndPositionOut: REAL;
	OffsetPosition: REAL;
	OffsetAlarmPosition: REAL;
	PositionPhysicalMeasured: REAL;
	///IF true, then movement of the cylinder is blocked by the red hot safetyrules.
	RHSR_Blocked: BOOL;
	ManSpeedCreepIn: REAL;
	ManSpeedCreepOut: REAL;
	ManSpeedSlowIn: REAL;
	ManSpeedSlowOut: REAL;
	ManSpeedIn: REAL;
	ManSpeedOut: REAL;
	/// Cycle information 
	mxCycleBusy: BOOL;
	mxInitBusy: BOOL;
END_VAR
VAR_OUTPUT
	///Errors
	Errors: ST_HydraulicErrorsAnalog;
	/// Error, stop immediately. Initialisation neccesary 
	mxErrorInit: BOOL;
	/// Error, stop in position. Only reset neccesary 
	mxErrorStopinPos: BOOL;
	/// Vars 
	mxInitialized: BOOL;
	ActPosition: REAL;
	ActMeasuredPosition: REAL;
	mxSlowActive: BOOL;
	mxIsMovingIn: BOOL;
	mxIsMovingOut: BOOL;
	mxIsIn: BOOL;
	mxIsOut: BOOL;
	mxMoveIn: BOOL;
	mxMoveOut: BOOL;
END_VAR
VAR	
	RodSidePressure: FB_AnalogIn4_20mA;
	BottomSidePressure: FB_AnalogIn4_20mA;
	/// Objects 
	HydraulicValve: FB_AnalogOutMinus10_10V;
	HydraulicPos: FB_BalluffPosition;
	MachPar: ST_HydraulicCilinderMachParAnalog;
	/// Destination position 
	EndPosition: REAL;
	/// Slow position 
	SlowPosition: REAL;
	FT_ValveInOff: F_TRIG;
	FT_ValveOutOff: F_TRIG;
	HydraulicStoredPosition: REAL;
	ixEndSwitchA AT %I*: BOOL;
	ixEndSwitchB AT %I*: BOOL;
	ixMSPAReadyToOperate AT %I*: BOOL;
	qxMSPAEnable AT %Q*: BOOL;
	mxMoveReadyWithoutMoving: BOOL;
	RT_Emergency: R_Trig;
	FT_AutoMode: F_TRIG;
	SafePosReached: BOOL;
	Mancreep: BOOL;
	ManCreepUp: BOOL;
	ManSlowUp: BOOL;
	ManUp: BOOL;
	ManCreepDown: BOOL;
	ManSlowDown: BOOL;
	ManDown: BOOL;
	SR_RodSidePressureTooHigh: SR;
	SR_BotSidePressureTooHigh: SR;
	T_EmergencyDelay: TON;
	RT_EmergencyDelay: R_TRIG;
	T_EnableDelayedOff: TOF;
	mxTestValue: REAL;
	FT_ValveToNeutralPos: F_trig;
	SR_SafePositionNotReached: SR;
	ControlledManualy: BOOL;
	MemPosition: REAL;
	FT_MemPosition: F_TRIG;
	FT_ControlledManually: F_TRIG;
	FT_mxCycleBusy: F_TRIG;
	FT_mxInitBusy: F_TRIG;
END_VAR
VAR_IN_OUT
	PositionPhysicalMeasuredOld: REAL;
	PhysicalOffsetPos: REAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[Error();
Objects();
Manual();

RT_Emergency(CLK:= mxEmergency);
FT_AutoMode(CLK:=mxAutoMode);

// Enable MSPA2
T_EnableDelayedOff(IN:= NOT mxEmergency, PT:=T#500MS);
qxMSPAEnable := T_EnableDelayedOff.Q; 

// Calculate correction on actual balluf position to a virtual "zero" position.
IF PositionPhysicalMeasured <> PositionPhysicalMeasuredOld THEN
	PhysicalOffsetPos := (HydraulicPos.Position- (OffsetPosition + PositionPhysicalMeasured));
END_IF

// Create a virtual zero position by substracting a calculated offset
ActPosition:= HydraulicPos.Position - PhysicalOffsetPos;
ActMeasuredPosition:= HydraulicPos.Position;

mxIsMovingIn:= HydraulicValve.EngInput > 0;
mxIsMovingOut:= HydraulicValve.EngInput < 0;

// Hysteresis + 2 to enlarge the RHSR window.
mxIsIn:= (ActPosition <= (EndPositionIn + (MachPar.Hysteresis + 2))) AND (ActPosition >= (EndPositionIn - (MachPar.Hysteresis + 2)));
mxIsOut:= (ActPosition <= (EndPositionOut + (MachPar.Hysteresis + 2))) AND (ActPosition >= (EndPositionOut - (MachPar.Hysteresis + 2)));

(*Overwrite previous value*)
PositionPhysicalMeasuredOld := PositionPhysicalMeasured;

// Close valves on emergency stop.
IF RT_Emergency.Q OR FT_AutoMode.Q THEN
	HydraulicValve.EngInput := 0;
END_IF


// From the TOP bosch -> If both feedback signals are high, the valve can be considered "safe" (base position reached
SafePosReached:= ixEndSwitchA AND ixEndSwitchB;



// Bateu 20190317

// niet manual bedient. 
// niet init bezig.
// niet cyclus actief.	
ControlledManualy := (ManDown OR ManSlowDown OR ManCreepDown OR ManUp OR ManSlowUp OR ManCreepUp) AND NOT mxAutoMode; 

FT_ControlledManually(CLK:=ControlledManualy);
FT_mxCycleBusy(CLK:=mxCycleBusy);
FT_mxInitBusy(CLK:=mxInitBusy);

// When in manual and control has stopped. Save current position. 

IF FT_ControlledManually.Q OR FT_mxCycleBusy.q OR FT_mxInitBusy.q THEN
	MemPosition := ActPosition;
END_IF;	
							 
IF NOT ControlledManualy AND NOT mxCycleBusy AND NOT mxInitBusy THEN	// Keep in its "up" position.
	M_Move(EndPosition:= MemPosition,  NormalSpeed:= ManSpeedCreepIn (*ManSpeedSlowIn*), 		
			SlowPosition:= MemPosition - 25, SlowSpeed:= ManSpeedCreepIn(*ManSpeedSlowIn*)	, 
			CreepPosition:=MemPosition - 10, CreepSpeed:=ManSpeedCreepIn);
END_IF



]]></ST>
    </Implementation>
    <Action Name="Error" Id="{c1a8f428-ab82-4542-866b-d20534fe250f}">
      <Implementation>
        <ST><![CDATA[Errors.BallufError:= HydraulicPos.Error;

// Check for a to high a pressure
SR_RodSidePressureTooHigh(SET1:=mxIsMovingIn AND (RodSidePressure.EngFilt > MachPar.MaxRodSidePressure),Reset:=mxReset,Q1=>Errors.RodSidePressureTooHigh);
SR_BotSidePressureTooHigh(SET1:=mxIsMovingOut AND (BottomSidePressure.EngFilt > MachPar.MaxBotSidePressure),Reset:=mxReset,Q1=>Errors.BotSidePressureTooHigh);	 

SR_SafePositionNotReached(SET1:=T_EmergencyDelay.Q AND NOT SafePosReached, reset:=mxReset, Q1=>Errors.SafePositionValveNotReached);

// Delay the emstop from the doors open, and wait checking on position.
T_EmergencyDelay(IN:=mxEmergency, PT:=T#500MS);
RT_EmergencyDelay(CLK:=T_EmergencyDelay.Q);

(* Als valve up/down uit gaat, positie opslaan en controleren of deze veranderd tov de act positie*)
IF RT_EmergencyDelay.Q THEN 
	HydraulicStoredPosition:= ActPosition; 
END_IF
IF mxReset THEN
	HydraulicStoredPosition:= ActPosition;
	Errors.IsMovingWithoutActivation:= FALSE;
ELSIF (T_EmergencyDelay.Q OR (HydraulicValve.EngInput = 0)) AND ((HydraulicStoredPosition > (ActPosition + 10)) OR (HydraulicStoredPosition < (ActPosition - 10))) THEN
	//Errors.IsMovingWithoutActivation:= TRUE;
END_IF

// Look into above alarm, this keeps triggering, probably due to not setting actual position in the right way

(***************************************************************************************)
mxErrorStopInPos:= FALSE;
mxErrorInit:= Errors.IsMovingWithoutActivation; //OR Errors.BotSidePressureTooHigh OR Errors.RodSidePressureTooHigh;]]></ST>
      </Implementation>
    </Action>
    <Method Name="M_Move" Id="{c362a816-6b78-4ee6-b85c-91d27de608d2}">
      <Declaration><![CDATA[METHOD M_Move : BOOL
VAR_INPUT
	/// Destination position 
	EndPosition: REAL;
	NormalSpeed: REAL;
	/// Slow position 
	SlowPosition: REAL;
	SlowSpeed: REAL;
	///CreepSpeed.
	CreepPosition: REAL;
	CreepSpeed: REAL;
END_VAR
VAR
	mxMoveINReady: BOOL;
	mxMoveOutReady: BOOL;
	ActSpeed: REAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mxMoveReadyWithoutMoving := FALSE;

//Check current position of the rod, and check where to go and detemine direction
IF ActPosition > (EndPosition + MachPar.Hysteresis) THEN		// Move up (Positive)
	(*Set movement direction bit.*)
	mxMoveIn:= FALSE;
	mxMoveOut:= TRUE;
	ActSpeed:= NormalSpeed;
ELSIF ActPosition < (EndPosition - MachPar.Hysteresis) THEN 	// Move Down (Negative)
	(*Set movement direction bit.*)
	mxMoveIn:= TRUE;
	mxMoveOut:= FALSE;
	ActSpeed:= NormalSpeed;
ELSE																			// Don't move at all (allready on pos).
	mxMoveIn:= FALSE;
	mxMoveOut:= FALSE;
	mxMoveReadyWithoutMoving := TRUE;
END_IF

// Check at which speed the movement needs to be done.
IF (NOT mxMoveIn AND NOT mxMoveOut) THEN	// No movement.
	ActSpeed:= 0;
ELSIF (mxMoveIn AND (ActPosition > CreepPosition)) OR (mxMoveOut AND (ActPosition < CreepPosition)) THEN 	//Creep speed.
	ActSpeed:= CreepSpeed;
ELSIF (mxMoveIn AND (ActPosition > SlowPosition)) OR (mxMoveOut AND (ActPosition < SlowPosition)) THEN 		//Slow speed.
	ActSpeed:= SlowSpeed;
ELSIF (mxMoveIn OR mxMoveOut) THEN	// Normal speed if nothing else is selected.
	ActSpeed:= NormalSpeed;
END_IF

// Set actual output on valve.
IF mxMoveOut THEN ActSpeed := Actspeed *-1; END_IF
HydraulicValve.EngInput := ActSpeed;

// Check if the movement is ready.
mxMoveInReady := (mxMoveIn AND ((ActPosition >= (EndPosition - MachPar.Hysteresis)) AND 
				(ActPosition <= (EndPosition + MachPar.Hysteresis))));
mxMoveOutReady := (mxMoveOut AND ((ActPosition >= (EndPosition - MachPar.Hysteresis)) AND 
				(ActPosition <= (EndPosition + MachPar.Hysteresis))));	

// reset directional bits to zero when leaving this method.
IF mxMoveInReady OR mxMoveOutReady OR mxMoveReadyWithoutMoving THEN
	mxMoveIn:= FALSE;
	mxMoveOut:= FALSE;
END_IF

// Signal the method has finished to the caller of the method.
M_MOVE := mxMoveInReady OR mxMoveOutReady OR mxMoveReadyWithoutMoving; ]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_OpenAndMove" Id="{1bca8383-6f76-437b-af9c-d968d2c4bba0}">
      <Declaration><![CDATA[METHOD M_OpenAndMove : BOOL
VAR_INPUT
	/// Destination position 
	EndPosition: REAL;
	NormalSpeed: REAL;
	/// Slow position 
	SlowPosition: REAL;
	SlowSpeed: REAL;
	///CreepSpeed.
	CreepPosition: REAL;
	CreepSpeed: REAL;
	OpenPosition: REAL;
	OpenSpeed: REAL;
END_VAR
VAR
	mxMoveINReady: BOOL;
	mxMoveOutReady: BOOL;
	ActSpeed: REAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mxMoveReadyWithoutMoving := FALSE;

//Check current position of the rod, and check where to go and detemine direction
IF ActPosition > (EndPosition + MachPar.Hysteresis) THEN		// Move up (Positive)
	(*Set movement direction bit.*)
	mxMoveIn:= FALSE;
	mxMoveOut:= TRUE;
	ActSpeed:= NormalSpeed;
ELSIF ActPosition < (EndPosition - MachPar.Hysteresis) THEN 	// Move Down (Negative)
	(*Set movement direction bit.*)
	mxMoveIn:= TRUE;
	mxMoveOut:= FALSE;
	ActSpeed:= NormalSpeed;
ELSE																			// Don't move at all (allready on pos).
	mxMoveIn:= FALSE;
	mxMoveOut:= FALSE;
	mxMoveReadyWithoutMoving := TRUE;
END_IF

// Check at which speed the movement needs to be done.
IF (NOT mxMoveIn AND NOT mxMoveOut) THEN	// No movement.
	ActSpeed:= 0;
ELSIF (mxMoveIn AND (ActPosition > CreepPosition)) OR (mxMoveOut AND (ActPosition < CreepPosition)) THEN 	//Creep speed.
	ActSpeed:= CreepSpeed;
ELSIF (mxMoveIn AND (ActPosition > SlowPosition)) OR (mxMoveOut AND (ActPosition < SlowPosition)) THEN 		//Slow speed.
	ActSpeed:= SlowSpeed;
ELSIF (mxMoveIn AND (ActPosition < OpenPosition)) THEN 		//Only do this on way up.
	ActSpeed:= OpenSpeed;
ELSIF (mxMoveIn OR mxMoveOut) THEN	// Normal speed if nothing else is selected.
	ActSpeed:= NormalSpeed;
END_IF

// Set actual output on valve.
IF mxMoveOut THEN ActSpeed := Actspeed *-1; END_IF
HydraulicValve.EngInput := ActSpeed;

// Check if the movement is ready.
mxMoveInReady := (mxMoveIn AND ((ActPosition >= (EndPosition - MachPar.Hysteresis)) AND 
				(ActPosition <= (EndPosition + MachPar.Hysteresis))));
mxMoveOutReady := (mxMoveOut AND ((ActPosition >= (EndPosition - MachPar.Hysteresis)) AND 
				(ActPosition <= (EndPosition + MachPar.Hysteresis))));	

// reset directional bits to zero when leaving this method.
IF mxMoveInReady OR mxMoveOutReady OR mxMoveReadyWithoutMoving THEN
	mxMoveIn:= FALSE;
	mxMoveOut:= FALSE;
END_IF

// Signal the method has finished to the caller of the method.
M_OpenAndMove := mxMoveInReady OR mxMoveOutReady OR mxMoveReadyWithoutMoving; ]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Press" Id="{a5a9a7da-78ff-48aa-8723-3dc409991b96}">
      <Declaration><![CDATA[METHOD M_Press : BOOL
VAR_INPUT
	/// Determines if press needs to be done moving down 
	PressDown: BOOL;
	/// Flow at which the pressing occures
	PressSpeed: REAL;
	/// Pressure at which the pressing stops
	StoppingPressure: REAL;
END_VAR
VAR
	PressingDone: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF PressDown THEN	// PressDown
	IF (BottomSidePressure.EngFilt < StoppingPressure - 15) THEN
		HydraulicValve.EngInput := PressSpeed * -1;
	END_IF
		
	IF (BottomSidePressure.EngFilt > StoppingPressure) THEN 
		HydraulicValve.EngInput := 0;			
		M_Press := TRUE;	// Signal the method is done.
	END_IF 	
ELSE				// PressUp
	IF (RodSidePressure.EngFilt < StoppingPressure) THEN
		HydraulicValve.EngInput := PressSpeed;
	ELSE
		HydraulicValve.EngInput := 0;	
		M_Press := TRUE;	// Signal the method is done.
	END_IF 
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Stop" Id="{5f3d7195-b507-48fd-9117-4dcff1d4dc46}">
      <Declaration><![CDATA[METHOD M_Stop : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mxMoveIn := FALSE;
mxMoveOut := FALSE;

HydraulicValve.EngInput := 0.0;

M_Stop:= TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopDirect" Id="{a5c23189-cbe6-4a48-92c6-b3494ab42cf9}">
      <Declaration><![CDATA[METHOD M_StopDirect
]]></Declaration>
      <Implementation>
        <ST><![CDATA[HydraulicValve.EngInput := 0.0;
]]></ST>
      </Implementation>
    </Method>
    <Action Name="Manual" Id="{a6b1b29a-9682-4089-adbf-23360c8c6891}">
      <Implementation>
        <ST><![CDATA[IF ManCreepUp THEN
	HydraulicValve.EngInput := ManSpeedCreepIn;
ELSIF ManSlowUp THEN
	HydraulicValve.EngInput := ManSpeedSlowIn;
ELSIF ManUp THEN
	HydraulicValve.EngInput := ManSpeedIn;
ELSIF ManCreepDown THEN
	HydraulicValve.EngInput := ManSpeedCreepOut * -1;
ELSIF ManSlowDown THEN
	HydraulicValve.EngInput := ManSpeedslowOut * -1;
ELSIF ManDown THEN											// Somebody is seriously wounded. ^_^
	HydraulicValve.EngInput := ManSpeedOut * -1;
END_IF

(* Discontinued because of keeping the hydraulics on pos. (And because of leaks closing was not enough)
FT_ValveToNeutralPos(CLK:=ManCreepUp OR ManSlowUp OR ManUp OR ManCreepDown OR ManSlowDown OR ManDown);

// When Automode is disabled, set the valve back to neutral position.
IF FT_AutoMode.Q OR Ft_ValveToNeutralPos.Q THEN
	HydraulicValve.EngInput := 0.0;
END_IF
*)
	
	
	


]]></ST>
      </Implementation>
    </Action>
    <Action Name="Objects" Id="{005cf89f-37c9-49d3-ba5b-7ecfee48fe32}">
      <Implementation>
        <ST><![CDATA[(* Objects Call *)
BottomSidePressure(
	EngLowLimit:=0, 
	EngUpperLimit:=315, 
	maOut=> , 
	EngUnits=> , 
	EngFilt=> , 
	OverRange=> , 
	UnderRange=> );

RodSidePressure(
	EngLowLimit:=0, 
	EngUpperLimit:=315, 
	maOut=> , 
	EngUnits=> , 
	EngFilt=> ,
	OverRange=> ,
	UnderRange=> );
	
HydraulicValve( 
	EngMin:= -100,
	EngMax:= 100,
	RHSR_Blocked:= RHSR_Blocked,
	VOut=> , 
	RawOut=> );
	
HydraulicPos();]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_HydraulicCilinderAnalog">
      <LineId Id="3" Count="46" />
      <LineId Id="153" Count="0" />
      <LineId Id="156" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="50" Count="14" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.Error">
      <LineId Id="75" Count="26" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.M_Move">
      <LineId Id="3" Count="46" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.M_OpenAndMove">
      <LineId Id="3" Count="48" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.M_Press">
      <LineId Id="3" Count="17" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.M_Stop">
      <LineId Id="3" Count="4" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.M_StopDirect">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.Manual">
      <LineId Id="2" Count="26" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_HydraulicCilinderAnalog.Objects">
      <LineId Id="2" Count="25" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>