<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="FB_TransferMold" Id="{696ef212-8dad-48c1-b23b-38fa575ac7c4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_TransferMold
VAR CONSTANT
	sCycleStateTextDef: ARRAY[0..25]  OF STRING :=	
		['State 0: Wait for Start',
		'State 1: Wait for product forming ready',
		'State 2: Move down',
		'State 3: Wait for move up signal from main cycle',
		'State 4: Move up with product, signal bottommold when free to move',
		'State 5: Wait for bottommold A or B is at IN position',
		'State 6: Move down tranfer to bottommold transfer position',
		'State 7: Transfer time (closed on bottommold)',
		'State 8: Move up with blowoff and stop blowoff at tranfermold position',
		'State 9: Wait for bottommold is out',
		'State 10: ',
		'State 11: ',
		'State 12: ',
		'State 13:',
		'State 14:',
		'State 15:',
		'State 16:',
		'State 17:',
		'State 18:',
		'State 19:',
		'State 20: [Pausing] Stop al hydraulic movement',
		'State 21: [Pausing] Move transfermold to up pause position',
		'State 22: [Paused] Wait for start',
		'State 23:',
		'State 24:',
		'State 25: Stop direct'];
	
	tCycleStateTimeouts: ARRAY[0..25] OF TIME := 
		[T#600S, 	// State 0:  Wait for Start
		T#5S,		// State 1:  Wait for product forming ready
		T#5S,		// State 2:  Move down
		T#5S,		// State 3:  Wait for move up signal from main cycle
		T#5S,		// State 4:  Move up with product, signal bottommold when free to move
		T#5S,		// State 5:  Wait for bottommold A or B is at IN position
		T#5S,		// State 6:  Move down tranfer to bottommold transfer position
		T#5S,		// State 7:  Transfer time (closed on bottommold)
		T#5S,		// State 8:  Move up with blowoff and stop blowoff at tranfermold position
		T#5S,		// State 9:  Wait for bottommold is out
		T#5S,		// State 10: 
		T#5S,		// State 11: 
		T#5S,		// State 12: 
		T#5S,		// State 13: 
		T#5S,		// State 14: 
		T#5S,		// State 15: 
		T#5S,		// State 16: 
		T#5S,		// State 17: 
		T#5S,		// State 18: 
		T#5S,		// State 19: 
		T#5S,		// State 20: [Pausing] Stop al hydraulic movement 
		T#5S,		// State 21: [Pausing] Move transfermold to up pause position
		T#5S,		// State 22: [Paused] Wait for start
		T#5S,		// State 23: 
		T#5S,		// State 24: 
		T#5S];		// State 25: Stop direct

	sInitStateTextDef: ARRAY[0..10] OF STRING :=
		['State 0: Wait for Init Start',
		'State 1: Move transfermold to up position',
		'State 2: Description Init State 2',
		'State 3: Description Init State 3',
		'State 4: Description Init State 4',
		'State 5: Description Init State 5',
		'State 6: Description Init State 6',
		'State 7: Description Init State 7',
		'State 8: Description Init State 8',
		'State 9: Description Init State 9',
		'State 10: Stop init state'];

	tInitStateTimeouts: ARRAY[0..10] OF TIME := 
		[T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S
		,T#10S];
END_VAR

VAR_INPUT
	mxReset							: BOOL;	(*Reset Error*)
	mxEmergency						: BOOL;
	mxAutoMode						: BOOL; (* TRUE = Automode *)
	mxEmptyMachine					: BOOL;

	mxResetCycleState				: BOOL;
	mxResetInitState				: BOOL;
	
	mxStartVacuum					: BOOL; (* Signal from product forming *)

	mxStartProductForming			: BOOL;
	RHSR_Blocked 					: BOOL;

	(*Singals.*)
	sgMoveUp						: BOOL; (* Signal from product forming *)
	sgMoveToTransferPosA			: BOOL;
	sgMoveToTransferPosB			: BOOL;
	sgMoveDownToFormingPos			: BOOL; (* Signal from product forming *)
	sgTrAtFormingPos				: BOOL; (* Signal to Product Forming, that transfer is down*)
	sgTrReleaseBmMoveIn				: BOOL; (* Signal to bottommold, is up, move in  *)
	sgTransferIsUpMoveOut			: BOOL; (* Signal to bottommold, is up, move out *)
	sgBottomMoldAIsOut				: BOOL;
	sgBottomMoldBIsOut				: BOOL;
	sgSample: BOOL;
END_VAR
VAR_IN_OUT
	ProdParameters					: ST_TransferMoldProdPar;
	MachParameters					: ST_TransferMoldMachPar;
END_VAR
VAR_OUTPUT
(*Errors*)
	Errors							: ST_TransferMoldErrors;
	mxErrorInit						: BOOL;		(* Error, stop immediately. Initialisation neccesary *)
	mxErrorStopinPos				: BOOL;		(* Error, stop in position. Only reset neccesary *)

(* State vars *)
	mxCycleBusy						: BOOL;
	mxInitBusy						: BOOL;
	
(* Vars *)
	mxInitialized					: BOOL;
	
	mxCilIsMovingIn					: BOOL;
	mxCilIsMovingOut				: BOOL;
	mxCilIsIn						: BOOL;
	mxCilIsOut						: BOOL;	

	DownPosition					: REAL; // Position at which the transfermold thinks its down.
	ActualPosition					: REAL;
	
	mxTransferIsUpMoveOutA			: BOOL; (* Signal to bottom Mold, move out *)
	mxTransferIsUpMoveOutB			: BOOL; (* Signal to bottom Mold, move out *)

	TransferPosA					: REAL;
	TransferPosB					: REAL;
END_VAR
VAR
(* State vars *)
	miCycleState					: INT :=0;
	miCycleOldstate					: INT :=0;
	mxCycleTransitionState			: BOOL := FALSE;
	sCycleStateText					: STRING;
	exCycleTimeOut					: BOOL;		(* Timeout for the whole programcycle *)
	CycleTimeout					: TON;
	CycleTimeOutUpFlank				: R_TRIG;
	mxCycleTimeoutEnable			: BOOL;
	CycleTime						: REAL;
	mxCycleHasError					: BOOL;
	miStopState						: INT;
	mxStartCycle					: BOOL;
	mxStopCycle						: BOOL;
	mxStopDirect					: BOOL;
	
	miInitState						: INT	:=0;
	miInitOldstate					: INT	:=0;
	mxInitTransitionState			: BOOL	:= FALSE;
	sInitStateText					: STRING;
	exInitTimeOut					: BOOL;		(* Timeout for the whole programcycle *)
	InitTimeout						: TON;
	InitTimeOutUpFlank				: R_TRIG;
	mxInitTimeoutEnable				: BOOL;
	InitTime						: REAL;
	mxInitHasError					: BOOL;
	mxStartInit						: BOOL;
	mxStopInit						: BOOL;
	

(* Objects *)
	HydraulicCilinder				: FB_HydraulicCilinderAnalog; (* Up, Down, Slow, Position *)
	Vacuum							: FB_MonoValveNoFdbck;	(* IMD-Y-082 *)		
	BlowOff							: FB_MonoValveNoFdbck;	(* IMD-Y-076 *)

(* Vars *)
	T_TransferTimeClosed			: TON;
	T_BlowOff						: TON;

	mxTransferToA					: BOOL;
	mxTransferToB					: BOOL;
	T_FormingTime					: TON;
	RT_StartForming					: R_TRIG;
	
	PositionHighSlow				: REAL;
	InitSlowPosition				: REAL;
	T_PauseDelayedUp: TON;
	mxInPause						: BOOL;
	T_TrToBmTimeout: TON;
	SR_TrDidNotReachTransferPos: SR;
	SR_TrDidNotReachFormingPos: SR;
	T_TrToFormTimeOut: TON;
	RT_TakeSample: R_TRIG;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[Error();
Init();
Cycle();
Objects();

ActualPosition := HydraulicCilinder.ActPosition;
DownPosition := ProdParameters.PositionDownStop;

TransferPosA := ProdParameters.PositionTransferStopA;
TransferPosB := ProdParameters.PositionTransferStopB;]]></ST>
    </Implementation>
    <Action Name="Cycle" Id="{76d454ba-1255-4557-ba0b-a2fd6e8c020d}">
      <Implementation>
        <ST><![CDATA[(*StateChange (Transition)  Signalgeneration*)
mxCycleTransitionState:=(miCycleState<>miCycleOldstate);
(*State text*)
sCycleStateText:=sCycleStateTextDef[miCycleState];
(*Timeout Watchdog for Statemachine*)
mxCycleTimeoutEnable:=NOT (miCycleState=0) AND NOT mxReset;

CycleTimeout(IN:=mxCycleTimeoutEnable, PT:=tCycleStateTimeouts[miCycleState] );
CycleTimeOutUpFlank(CLK:=CycleTimeout.Q );
miCycleOldstate:=miCycleState;

(*Set Errorbit when Raising edge of Timeout has been detected*)
IF CycleTimeOutUpFlank.Q THEN
	exCycleTimeOut:=TRUE; 			(* 1 Timeout for the whole programcycle *)
END_IF

(*Function to reset the Statemachine*)
IF mxResetCycleState THEN
	mxResetCycleState:= FALSE;
	mxInitialized := FALSE;
	
	miCycleState:=0;
	miCycleOldstate:=miCycleState;
	mxCycleTransitionState:=FALSE;

	T_TransferTimeClosed.IN:= FALSE;
	T_BlowOff.IN:= FALSE;
	sgTrReleaseBmMoveIn:= FALSE;
	sgTrAtFormingPos:= FALSE;
	mxTransferToA:= FALSE;
	mxTransferToB:= FALSE;
	sgTrReleaseBmMoveIn := FALSE;
	sgMoveToTransferPosA := FALSE;
	sgMoveToTransferPosB := FALSE;	
	mxTransferIsUpMoveOutA := FALSE;
	mxTransferIsUpMoveOutB := FALSE;
	SgTransferIsUpMoveOut := FALSE;
	sgMoveDownToFormingPos := FALSE;
	 mxEmptyMachine :=FALSE;
	T_TrToBmTimeout.IN := FALSE;
	T_TrToFormTimeOut.IN:=FALSE;
	sgSample:=FALSE;		
	mxStartCycle:= FALSE;
	mxStopCycle:= FALSE;
	mxStopDirect:=FALSE;
	
	HydraulicCilinder.M_Stop();
END_IF

(*Definition State has Error*)
mxCycleHasError:=FALSE;

T_TransferTimeClosed(PT:= MachParameters.TransferTimeClosed);
T_PauseDelayedUp(PT:=T#300MS);
T_TrToBmTimeout(PT:=T#5S);
T_TrToFormTimeOut(PT:=T#7S);

// When moving up with product (Step 6), start forming at forming position parameter
RT_StartForming(CLK:=((HydraulicCilinder.ActPosition >= MachParameters.PositionStartFormingProcess)AND (miCycleState=4)));
RT_TakeSample(CLK:=sgSample);

IF RT_TakeSample.Q THEN	Vacuum.M_Off(); END_IF
IF T_BlowOff.Q THEN BlowOff.M_Off(); END_IF

{region "copy parameter set for pause position movement"}
	 MachParameters.PausePositionUpSlow := MachParameters.PositionUpSlow;	
	 MachParameters.PausePositionUpCreep := MachParameters.PositionUpCreep;	
{endregion}

(*Cycle State's*)
CASE miCycleState OF
	0:  //(P) Wait for start from IMD
		IF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 20;
		ELSIF mxStartCycle THEN
			mxStartCycle:= FALSE;	
			miCycleState:= 1;
		END_IF

	1:  //(P)  Wait for formming product ready
		 HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= MachParameters.UpNormalSpeed, // Use the move method to keep the transfermold in its "UpStop" Postion.
									SlowPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpSlow, SlowSpeed:=MachParameters.UpSlowSpeed,
									CreepPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpCreep, CreepSpeed:=MachParameters.UpCreepSpeed);
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle AND mxEmptyMachine THEN
			mxStopCycle:= FALSE;
			mxEmptyMachine:= FALSE;
			HydraulicCilinder.M_Stop();
			miCycleState:= 0;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 20;
		ELSIF sgMoveDownToFormingPos THEN	// signal from the Main cycle
			sgMoveDownToFormingPos:= FALSE;
			miCycleState:=2;
		END_IF
	
	2:  //(NP) Move transfer down to forming and open vacuum valve at pos X
		T_TrToFormTimeOut.IN:=TRUE;	
	
		IF HydraulicCilinder.ActPosition < (ProdParameters.PositionDownStop + MachParameters.PosDownStartVacOffset) THEN
			Vacuum.M_On();
		END_IF
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF HydraulicCilinder.M_Move(EndPosition:=ProdParameters.PositionDownStop, NormalSpeed:= MachParameters.DownSpeed, 
										SlowPosition:=ProdParameters.PositionDownStop + MachParameters.PositionDownSlow, SlowSpeed:=MachParameters.DownSpeedSlow,
										CreepPosition:=ProdParameters.PositionDownStop + MachParameters.PositionDownCreep, CreepSpeed:=MachParameters.DownSpeedCreep) OR T_TrToFormTimeOut.Q THEN		
			sgTrAtFormingPos:= TRUE;
			T_TrToFormTimeOut.IN:=FALSE;	
			miCycleState:= 3;
		END_IF
	
	3:  //(NP) Wait for product move signal from main cycle
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF sgMoveUp THEN
			sgMoveUp:= FALSE;
			miCycleState:= 4;
		END_IF
	
	4:	//(NP) Move up with product and signal when bottommold is free to move.
		IF RT_StartForming.q THEN
			mxStartProductForming:= TRUE;
		END_IF
		IF HydraulicCilinder.ActPosition > (MachParameters.PositionUpStop - ProdParameters.ReleaseBmMovementOffset) THEN 
			sgTrReleaseBmMoveIn := TRUE;
		END_IF;
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= MachParameters.UpNormalSpeed, 
											SlowPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpSlow, SlowSpeed:=MachParameters.UpSlowSpeed,
											CreepPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpCreep, CreepSpeed:=MachParameters.UpCreepSpeed) THEN
			miCycleState:= 5;
		END_IF
				
	5: 	//(P)  Wait for bottom mold A OR B is IN 
		 HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= MachParameters.UpNormalSpeed, 	// Use the move method to keep the transfermold in its "UpStop" Postion.
									SlowPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpSlow, SlowSpeed:=MachParameters.UpSlowSpeed,
									CreepPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpCreep, CreepSpeed:=MachParameters.UpCreepSpeed);
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 20;
		ELSIF sgMoveToTransferPosA OR sgMoveToTransferPosB THEN
			sgTrReleaseBmMoveIn := FALSE;
			mxStartProductForming:= FALSE;
			miCycleState:= 6;
		END_IF
			
	6:	//(NP) Move transfer mold down to transfer position and close vacuum valve at pos X
		T_TrToBmTimeout.In := TRUE;		
	
		IF (sgMoveToTransferPosA AND (HydraulicCilinder.ActPosition < (ProdParameters.PositionTransferStopA + MachParameters.PosTrStopVacOffset))) OR
 			(sgMoveToTransferPosB AND (HydraulicCilinder.ActPosition < (ProdParameters.PositionTransferStopB + MachParameters.PosTrStopVacOffset)))THEN
			Vacuum.M_Off();
		END_IF
		// Removed from step 9 at the request of mathijs wever:
		(*	Removed and moved Blowff.M_On to when the transfermold is closed on the bottommold. on the request of Matthijs Wever.
		IF (sgMoveToTransferPosA AND (HydraulicCilinder.ActPosition < ( ProdParameters.PositionTransferStopA + MachParameters.PosTrStartBlowOffOffset))) OR
			(sgMoveToTransferPosB AND (HydraulicCilinder.ActPosition < ( ProdParameters.PositionTransferStopB + MachParameters.PosTrStartBlowOffOffset))) THEN
			BlowOff.M_On();
		END_IF
		*)
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF sgMoveToTransferPosA THEN // A-Side mold.
			IF HydraulicCilinder.M_Move(EndPosition:=ProdParameters.PositionTransferStopA, NormalSpeed:= machParameters.DownSpeedToBm, 
										SlowPosition:=ProdParameters.PositionTransferStopA + MachParameters.PositionTransferSlow, machParameters.DownSpeedSlowToBm,
										CreepPosition:=ProdParameters.PositionTransferStopA + MachParameters.PositionTransferCreep, CreepSpeed:=machParameters.DownSpeedCreepToBm) OR T_TrToBmTimeout.Q THEN
				sgMoveToTransferPosA:= FALSE;
				mxTransferToA:= TRUE;
				mxTransferToB:= FALSE;
				BlowOff.M_On();			// BlowOff is now in this step, at the request of matthijs.
				T_TrToBmTimeout.In := FALSE;
				miCycleState:= 7;
			END_IF
		ELSIF sgMoveToTransferPosB THEN // B-side mold
			IF HydraulicCilinder.M_Move(EndPosition:=ProdParameters.PositionTransferStopB, NormalSpeed:= machParameters.DownSpeedToBm, 
										SlowPosition:=ProdParameters.PositionTransferStopB + MachParameters.PositionTransferSlow, SlowSpeed:=machParameters.DownSpeedSlowToBm,
										CreepPosition:=ProdParameters.PositionTransferStopB + MachParameters.PositionTransferCreep, CreepSpeed:=machParameters.DownSpeedCreepToBm) OR T_TrToBmTimeout.Q THEN
				sgMoveToTransferPosB:= FALSE;
				mxTransferToA:= FALSE;
				mxTransferToB:= TRUE;
				BlowOff.M_On();			// BlowOff is now in this step, at the request of matthijs.
				T_TrToBmTimeout.In := FALSE;
				miCycleState:= 7;
			END_IF
		END_IF

	7:  //(NP) Transfertime, while being closed*)
		T_TransferTimeClosed.IN:= TRUE;
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF T_TransferTimeClosed.Q THEN
			BlowOff.M_Off();
			T_TransferTimeClosed.IN:= FALSE;
			miCycleState:= 8;
		END_IF
	
	8:  //(NP) Move up with blowoff and stop blowoff at pos x of transfer
		(* // moved by the request of Siem H and Matthijs Wever
		IF (mxTransferToA AND (HydraulicCilinder.ActPosition < ( ProdParameters.PositionTransferStopA + MachParameters.PosTrStopBlowOffOffset))) OR
			(mxTransferToB AND (HydraulicCilinder.ActPosition < ( ProdParameters.PositionTransferStopB + MachParameters.PosTrStopBlowOffOffset))) THEN
			BlowOff.M_Off();
		END_IF*)
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= machParameters.UpNormalSpeedToBm, 
										SlowPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpSlow, SlowSpeed:=machParameters.UpSlowSpeedToBm,
										CreepPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpCreep, CreepSpeed:=machParameters.UpCreepSpeedToBm) THEN
			sgTransferIsUpMoveOut:= TRUE;	
			miCycleState:= 9;
		END_IF
	
	9:  //(P)  Wait for BottomMold is OUT 	
		 HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= MachParameters.UpNormalSpeed,  // Use the move method to keep the transfermold in its "UpStop" Postion.
									SlowPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpSlow, SlowSpeed:=MachParameters.UpSlowSpeed,
									CreepPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpCreep, CreepSpeed:=MachParameters.UpCreepSpeed);
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 20;
		ELSIF (mxTransferToA AND sgBottomMoldAIsOut) OR (mxTransferToB AND sgBottomMoldBIsOut) THEN
			sgBottomMoldAIsOut := FALSE;
			sgBottomMoldBIsOut := FALSE;
			miCycleState:= 1;
		END_IF
		
	20: //(NP) Pause step, stop all movement
		T_PauseDelayedUp.IN := TRUE;
		
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;	
			miCycleState:= 25;
		ELSIF T_PauseDelayedUp.Q AND HydraulicCilinder.M_Stop() THEN		
			miCycleState:= 21;
		END_IF

	21: //(NP) Move up to pause position 
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF HydraulicCilinder.M_Move(EndPosition:=MachParameters.PausePositionUp, NormalSpeed:= MachParameters.UpSlowSpeed, 
											SlowPosition:=MachParameters.PausePositionUp - MachParameters.PausePositionUpSlow, SlowSpeed:=MachParameters.UpSlowSpeed,
											CreepPosition:=MachParameters.PausePositionUp - MachParameters.PausePositionUpCreep, CreepSpeed:=MachParameters.UpCreepSpeed) THEN
			miCycleState := 22;
		END_IF
		
	22: //(Paused) Await restart. 
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:= 25;
		ELSIF mxStartCycle THEN
			IF HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= MachParameters.UpSlowSpeed, // Use the move method to keep the transfermold in its "UpStop" Postion.
									SlowPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpSlow, SlowSpeed:=MachParameters.UpSlowSpeed,
									CreepPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpCreep, CreepSpeed:=MachParameters.UpCreepSpeed) THEN
				mxStartCycle:= FALSE;
				sgSample:=FALSE;
				miCycleState:= miStopState;
			END_IF
		END_IF

	25: // Stop Direct 
		HydraulicCilinder.M_StopDirect();
		Vacuum.M_Off();
		BlowOff.M_Off();
		sgTrReleaseBmMoveIn:= FALSE;
		sgTrAtFormingPos:= FALSE;
		mxTransferToA:= FALSE;
		mxTransferToB:= FALSE;
		sgTrReleaseBmMoveIn := FALSE;
		sgMoveToTransferPosA := FALSE;
		sgMoveToTransferPosB := FALSE;	
		mxTransferIsUpMoveOutA := FALSE;
		mxTransferIsUpMoveOutB := FALSE;
		SgTransferIsUpMoveOut := FALSE;
		sgMoveDownToFormingPos := FALSE;
		mxStartCycle:= FALSE;
		mxStopCycle:= FALSE;
		mxStopDirect:=FALSE;
		T_TrToBmTimeout.In := FALSE;
		T_TrToFormTimeOut.IN:=FALSE;
		sgSample:=FALSE;
		mxInitialized := FALSE;
		miCycleState:= 0;

END_CASE

mxCycleBusy:= miCycleState <> 0 AND NOT (miCycleState= 22);
mxInPause := miCycleState=22;

]]></ST>
      </Implementation>
    </Action>
    <Action Name="Error" Id="{563f6ce1-47f0-4542-be72-f7f28d9eafe4}">
      <Implementation>
        <ST><![CDATA[SR_TrDidNotReachTransferPos(SET1:=T_TrToBmTimeout.Q, RESET:= mxReset, Q1=>Errors.TrDidNotReachBMPosTimeOut );
SR_TrDidNotReachFormingPos(SET1:=T_TrToFormTimeOut.Q, RESET:=mxReset, Q1=>Errors.TrDidNotReachFormingPosTimeOut);

(**********************************************************************************************************)
mxErrorStopinPos:= Errors.TrDidNotReachBMPosTimeOut OR Errors.TrDidNotReachFormingPosTimeOut;
mxErrorInit:= HydraulicCilinder.mxErrorInit;]]></ST>
      </Implementation>
    </Action>
    <Action Name="Init" Id="{0b654e89-9600-464c-ac50-bc0e8b7d9595}">
      <Implementation>
        <ST><![CDATA[(*StateChange (Transition)  Signalgeneration*)
mxInitTransitionState:=(miInitState<>miInitOldstate);
(*State text*)
sInitStateText:=sInitStateTextDef[miInitState];
(*Timeout Watchdog for Statemachine*)
mxInitTimeoutEnable:=NOT (miInitState=0)  AND NOT mxReset;

InitTimeout(IN:=mxInitTimeoutEnable  , PT:=tInitStateTimeouts[miInitState] );
InitTimeOutUpFlank(CLK:=InitTimeout.Q );
miInitOldstate:=miInitState;

(*Set Errorbit when Raising edge of Timeout has been detected*)
IF InitTimeOutUpFlank.Q THEN
	exInitTimeOut:=TRUE; 			(* 1 Timeout for the whole programcycle *)
END_IF

(*Function to reset the Statemachine*)
IF mxResetInitState THEN
	mxResetInitState:=FALSE;
	miInitState:=0;
	miInitOldstate:=miInitState;
	mxInitTransitionState:=FALSE;
	
	mxStartInit:= FALSE;
	mxStopInit:= FALSE;
END_IF

(*Definition State has Error*)
mxInitHasError:=FALSE;

PositionHighSlow := MachParameters.PositionUpStop + (MachParameters.PositionUpStop - MachParameters.PositionUpSlow);


(*Init State's*)
CASE miInitState OF
	0:
		IF mxStartInit THEN
			mxStartInit:= FALSE;

			mxInitialized:= FALSE;
	(* If product then not switch off ?? *)
			Vacuum.M_Off();
			BlowOff.M_Off();	
			
			miInitState:= 1;
		END_IF

	1:
		IF mxStopInit THEN
			mxStopInit:= FALSE;

			miInitState:= 2;
		END_IF
	
		// Above normal position
		IF HydraulicCilinder.ActPosition > MachParameters.PositionUpStop THEN
			IF HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= MachParameters.InitDownNormalSpeed, 
										SlowPosition:=MachParameters.PositionUpStop + MachParameters.PositionUpSlow, SlowSpeed:=MachParameters.InitDownSpeedSlow,
										CreepPosition:=MachParameters.PositionUpStop + MachParameters.PositionUpCreep, CreepSpeed:=MachParameters.InitDownSpeedCreep) THEN			
			mxInitialized:= TRUE;
			miInitState:= 0;
			END_IF
			
		// Below normal position
		ELSE
			IF HydraulicCilinder.M_Move(EndPosition:=MachParameters.PositionUpStop, NormalSpeed:= MachParameters.InitupNormalSpeed, 
							SlowPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpSlow, SlowSpeed:=MachParameters.InitUpSlowSpeed,
							CreepPosition:=MachParameters.PositionUpStop - MachParameters.PositionUpCreep, CreepSpeed:=MachParameters.InitUpCreepSpeed) THEN
			mxInitialized:= TRUE;
			miInitState:= 0;
			END_IF
		END_IF

	2:
		HydraulicCilinder.M_Stop();

		mxStartInit:= FALSE;
		mxStopInit:= FALSE;
		mxInitialized:=FALSE;					

		miInitState:= 0;
	
END_CASE

mxInitBusy:= miInitState<>0;]]></ST>
      </Implementation>
    </Action>
    <Method Name="M_EmptyMachine" Id="{331a32c7-9970-4c16-8502-a0c774a27047}">
      <Declaration><![CDATA[METHOD M_EmptyMachine
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF mxCycleBusy THEN
	mxEmptyMachine:= TRUE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StartCycle" Id="{dff44064-e5e9-44cf-8dd9-30e32d7e451d}">
      <Declaration><![CDATA[METHOD M_StartCycle
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT mxCycleBusy THEN
	mxStartCycle:= TRUE;	
	mxStopCycle:=False;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StartInit" Id="{78e1f08c-1d6f-4415-93f6-10db1dbb7671}">
      <Declaration><![CDATA[METHOD M_StartInit
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT mxInitBusy THEN 
	mxStartInit:= TRUE; 
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopCycle" Id="{a58e922a-4fda-448e-b8e8-bb435fa34a2a}">
      <Declaration><![CDATA[METHOD M_StopCycle
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mxStopCycle:= TRUE; 
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopDirect" Id="{3f86ea6c-cce1-4d51-9792-746497c3442d}">
      <Declaration><![CDATA[METHOD M_StopDirect
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF mxCycleBusy THEN
	mxStopDirect:= TRUE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopInit" Id="{d9778c72-6ec0-4c4a-8b71-fc5606061377}">
      <Declaration><![CDATA[METHOD M_StopInit
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF mxInitBusy THEN 
	mxStopInit:= TRUE; 
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Action Name="Objects" Id="{b7417f98-c5b4-43b0-bafa-06cb945be75c}">
      <Implementation>
        <ST><![CDATA[
HydraulicCilinder(
	mxReset:= mxReset,
	mxEmergency:= mxEmergency, 
	mxAutoMode:= mxAutoMode, 
	EndPositionIn:= MachParameters.PositionUpStop,
	EndPositionOut:= ProdParameters.PositionDownStop,
	OffsetPosition:= MachParameters. PositionOffsetZero,
	OffsetAlarmPosition:= MachParameters.PositionOffsetAlarm,
	PositionPhysicalMeasured:=MachParameters.PositionPhyscialMeasured,
	PositionPhysicalMeasuredOld:=MachParameters.PositionPhysicalMeasuredOld,
	PhysicalOffsetPos:=MachParameters.PhysicalOffsetPos,
	RHSR_Blocked:=RHSR_Blocked,
	mxCycleBusy:=mxCycleBusy,
	mxInitBusy:=mxInitBusy,
	mxIsMovingIn=> mxCilIsMovingIn, 
	mxIsMovingOut=> mxCilIsMovingOut,
	ManSpeedCreepIn:=MachParameters.ManSpeedCreep,
	ManSpeedCreepOut:=MachParameters.ManSpeedCreep,
	ManSpeedSlowIn:=MachParameters.ManSpeedSlow,
	ManSpeedSlowOut:=MachParameters.ManSpeedSlow,
	ManSpeedIn:=MachParameters.ManSpeed,
	ManSpeedOut:=MachParameters.ManSpeed,
	mxIsIn=> mxCilIsIn, 
	mxIsOut=> mxCilIsOut,
	Errors=> Errors.HydraulicCilinder);
	
Vacuum(
	mxReset:= mxReset, 
	mxAutoMode:= mxAutoMode);

BlowOff(
	mxReset:= mxReset, 
	mxAutoMode:= mxAutoMode);
]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_TransferMold">
      <LineId Id="230" Count="2" />
      <LineId Id="394" Count="1" />
      <LineId Id="398" Count="1" />
      <LineId Id="562" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.Cycle">
      <LineId Id="1187" Count="58" />
      <LineId Id="1504" Count="0" />
      <LineId Id="1496" Count="0" />
      <LineId Id="1246" Count="27" />
      <LineId Id="1490" Count="0" />
      <LineId Id="1274" Count="175" />
      <LineId Id="1492" Count="0" />
      <LineId Id="1451" Count="6" />
      <LineId Id="1507" Count="0" />
      <LineId Id="1458" Count="23" />
      <LineId Id="1508" Count="0" />
      <LineId Id="1491" Count="0" />
      <LineId Id="1482" Count="7" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.Error">
      <LineId Id="8" Count="4" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.Init">
      <LineId Id="32" Count="20" />
      <LineId Id="131" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="129" Count="1" />
      <LineId Id="56" Count="3" />
      <LineId Id="140" Count="1" />
      <LineId Id="150" Count="0" />
      <LineId Id="60" Count="2" />
      <LineId Id="90" Count="1" />
      <LineId Id="93" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="88" Count="1" />
      <LineId Id="105" Count="2" />
      <LineId Id="109" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="163" Count="6" />
      <LineId Id="180" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="170" Count="7" />
      <LineId Id="99" Count="0" />
      <LineId Id="103" Count="1" />
      <LineId Id="110" Count="1" />
      <LineId Id="132" Count="2" />
      <LineId Id="115" Count="1" />
      <LineId Id="63" Count="0" />
      <LineId Id="80" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.M_EmptyMachine">
      <LineId Id="56" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.M_StartCycle">
      <LineId Id="18" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.M_StartInit">
      <LineId Id="14" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.M_StopCycle">
      <LineId Id="11" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.M_StopDirect">
      <LineId Id="56" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.M_StopInit">
      <LineId Id="14" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TransferMold.Objects">
      <LineId Id="2" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="37" Count="2" />
      <LineId Id="41" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="73" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="81" Count="1" />
      <LineId Id="42" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="75" Count="5" />
      <LineId Id="70" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="10" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="13" Count="0" />
      <LineId Id="18" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>