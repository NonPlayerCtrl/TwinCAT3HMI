<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="FB_InMoldDrying" Id="{c18e6ac4-7922-4bb2-b934-de1694970bb6}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_InMoldDrying

VAR CONSTANT
	sCycleStateTextDef: ARRAY[0..100]  OF STRING :=	
		['State 0: Wait for Start',
		'State 1: Wait for product forming ready',
		'State 2: Wait for transfermold down at forming position',
		'State 3: Wait for productforming time closed',
		'State 4: Moving transfermold up',
		'State 5: spare',
		'State 6: Move bottommold A or B in',
		'State 7: Move transfermold up',
		'State 8: Move bottommold A or B Out',
		'State 9: Move topmold A or B down, await product forming ready',
		'State 10: Wait for transfermold down at forming position',
		'State 11: Move tranfermold up with product',
		'State 12: Await transfer and topmold A or B up to Release bottommold A/ B movement',
		'State 13: [Emptying] Move topmold A Or B up',
		'State 14: [Emptying] Move bottommold A or B in ',
		'State 15: [Emptying] Move bottommold A or B out',
		'State 16: [Emptying] Waiting on machine to empty',
		'State 17: [Emptying] Stopping subparts',
		'State 18: [Emptying] Check if everything has stopped',
		'State 19: [Pausing] Stopping sub objects.',
		'State 20: [Pausing] Pause the hydraulic system',
		'State 21: [Paused] await start',
		'State 22: [Restart] Restart sub parts',
		'State 23: Spare',
		'State 24: Spare',
		'State 25: [Stopped direct]'];
	
	tCycleStateTimeouts: ARRAY[0..10] OF TIME := 
		[T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,
		T#10S];

	sInitStateTextDef: ARRAY[0..10] OF STRING :=
		['State 0: Wait for Start',
		'State 1',
		'State 2: Init transfermold and machinepond',
		'State 3: Init top mold A',
		'State 4: Init Bottom mold A',
		'State 5: Init Top mold B',
		'State 6: Init Bottom mold B',
		'State 7: Set initalised bits and stop pump',
		'State 8',
		'State 9',
		'State 10: Stop init state'];

	tInitStateTimeouts: ARRAY[0..10] OF TIME := 
		[T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S,T#10S
		,T#10S];
END_VAR

VAR_INPUT
	mxResetCycleState				: BOOL;
	mxResetInitState				: BOOL;
	mxForceInit						: BOOL; (*Reset Calibration Flag*)
	mxReset							: BOOL;	(*Reset Error*)
	mxEmergency						: ARRAY [1..Max_Zones+1] OF BOOL; // 1=TakeOutA, 2=Aside, 3=mid, 4=Bside, 5=TakeoutB, 6= GantryB, 7=GantryA, 8=All EM stop.
	mxAutoMode						: BOOL; (* TRUE = Automode *)
	mxFirstCycle					: BOOL;
	mxSample						: BOOL; // Block vacuum of first bottommold in cycle at this bit.
	mxEnableHeating					: BOOL;
	
	mxStartFormingA					: BOOL;	// Signal from speed control to start the forming process for A side (Used at top of cycle).
	mxStartFormingB					: BOOL;	// Signal from speed control to start the forming process for B side (Used at top of cycle).

	mxProductPickedUpGantry_A		: BOOL;
	mxProductPickedUpGantry_B		: BOOL;	
	mxGantryA_AtBelt				: BOOL;
	mxGantryB_AtBelt				: BOOL;
	mxGantrysNotBusy				: BOOL;
	PlcCycleTime					: REAL;
END_VAR
VAR_IN_OUT
	MachParameters					: ST_IMDMachPar;
	ProdParameters					: ST_IMDProdPar;
	SysParameters					: ST_IMDSysPar;
END_VAR
VAR_OUTPUT
(*Errors*)
	Errors							: ST_IMDErrors;
	mxErrorInit						: BOOL;		(* Error, stop immediately. Initialisation neccesary *)
	mxErrorStopinPos				: BOOL;		(* Error, stop in position. Only reset neccesary *)

(* State vars *)
	mxCycleBusy						: BOOL;
	mxInitBusy						: BOOL;

(* Signals *)
	mxProductReadyAtTakeout_A		: BOOL;
	mxProductReadyAtTakeout_B		: BOOL;	
	mxIsEmpty						: BOOL;
	mxStopBeforeSCstarted			: BOOL;
	
	mxFormingA_Ready				: BOOL;	// Signal to speed control to confirm the forming process for A side is started 
	mxFormingB_Ready				: BOOL;	// Signal to speed control to confirm the forming process for B side is started 
	
(* Vars *)
	mxInitialized					: BOOL;

	mxHydraulicsReady				: BOOL;
	mxRTO							: BOOL; // IMD indication that it is ready to run (speedcontrol).
	MaximumSpeed					: BOOL;	// Theoretical maximum speed (Speedcontrol).
	ActualSpeed						: BOOL; // No. of Ko's in last cycle
	
END_VAR
VAR
(* State vars *)
	miCycleState					: INT :=0;
	miCycleOldstate					: INT :=0;
	mxCycleTransitionState			: BOOL := FALSE;
	sCycleStateText					: STRING;
	exCycleTimeOut					: BOOL;		(* Timeout for the whole programcycle *)
	CycleTimeout					: TON;
	CycleTimeOutUpFlank				: R_TRIG;
	mxCycleTimeoutEnable			: BOOL;
	CycleTime						: REAL;
	mxCycleHasError					: BOOL;
	miStopState						: INT;
	mxStartCycle					: BOOL;
	mxStopCycle						: BOOL;
	mxStopCycleEmpty				: BOOL;
	mxStopDirect					: BOOL;
	
	miInitState						: INT	:=0;
	miInitOldstate					: INT	:=0;
	mxInitTransitionState			: BOOL	:= FALSE;
	sInitStateText					: STRING;
	exInitTimeOut					: BOOL;		(* Timeout for the whole programcycle *)
	InitTimeout						: TON;
	InitTimeOutUpFlank				: R_TRIG;
	mxInitTimeoutEnable				: BOOL;
	InitTime						: REAL;
	mxInitHasError					: BOOL;
	mxStartInit						: BOOL;
	mxStopInit						: BOOL;
	
(* Objects *)
	TopMoldA		 				: FB_TopMold;
	TopMoldB		 				: FB_TopMold;
	BottomMoldA						: FB_BottomMold;
	BottomMoldB						: FB_BottomMold;
	TransferMold					: FB_TransferMold;
	ProductForming					: FB_ProductForming;
	HydraulicsMain					: FB_HydraulicsMain;

(* Vars *)	
	mxStartTransferToBottomMold		: BOOL;	(* Signal to transfer mold *)


	
	FT_EnableASide					: F_TRIG;
	FT_EnableBSide					: F_TRig;
	
	mxSideAEnabled: BOOL;
	mxSideBEnabled: BOOL;
	
	SR_TrMoldIsMovingBoMoldANotInPos	: SR; (* RedHot SafetyRule, Transfermold is moving, Bottom Mold A not in position *)
	SR_TrMoldIsMovingBoMoldBNotInPos	: SR; (* RedHot SafetyRule, Transfermold is moving, Bottom Mold B not in position *)
	SR_TrMoldIsMovingSprayBNotInPos		: SR; (* RedHot SafetyRule, Transfermold is moving, spray bar not in position *)
	SR_ToMoldAIsMovingBoMoldANotInPos	: SR; (* RedHot SafetyRule, Topmold A is moving, Bottom Mold A not in position *)
	SR_ToMoldBIsMovingBoMoldBNotInPos	: SR; (* RedHot SafetyRule, Topmold B is moving, Bottom Mold B not in position *)
	SR_BoMoldAIsMovingTrMoldNotInPos	: SR; (* RedHot SafetyRule, Bottommold A is moving, Transfermold not in position *)
	SR_BoMoldBIsMovingTrMoldNotInPos	: SR; (* RedHot SafetyRule, Bottommold B is moving, Transfermold not in position *)
	SR_BoMoldAIsMovingToMoldANotInPos	: SR; (* RedHot SafetyRule, Bottommold A is moving, Topmold A not in position *)
	SR_BoMoldBIsMovingToMoldBNotInPos	: SR; (* RedHot SafetyRule, Bottommold B is moving, Topmold B not in position *)
	SR_TaOutHorAIsMovingVertIsNotDown	: SR; (* RedHot SafetyRule, Takeout unit A Horizontal is moving, Vertical not in position*)
	SR_TaOutHorBIsMovingVertIsNotDown	: SR; (* RedHot SafetyRule, Takeout unit A Horizontal is moving, Vertical not in position*)
	RT_ErrorInit						: R_TRIG;
	mxCommisioningMode					: BOOL;
	T_StopCommisioningMode				: TON;
	mxSafetyRulesEnabled				: BOOL;
	
	//VacuumTakeout					: ARRAY [1..6] OF FB_MonoValveNoFdbck;	(* IMD-V *)		
	SR_TempDeviationToHighA				: ARRAY[1..6] OF SR;
	SR_TempDeviationToHighB				: ARRAY[1..6] OF SR;

	ASideNotWarm						: BOOL;
	BSideNotWarm						: BOOL;
	SR_BotMoldAToCoolForTrMDown			: SR;
	SR_BotMoldBToCoolForTrMDown			: SR;
	
	mxInPause 							: BOOL;
	ProductDryingAtSideA				: BOOL;
	ProductDryingAtSideB				: BOOL;
	ContinueWithA						: BOOL;
	ContinueWithB						: BOOL;
	ProductOnTopMoldA					: BOOL;
	ProductOnTopMoldB					: BOOL;
	T_TransferReleasedBottom			: TON;
	T_TopReleasedBottom					: TON;
	T_TopReleasedBottomA				: TON;
	T_TopReleasedBottomB				: TON;
	TransferLateTime					: TIME;
	TopLateTime							: TIME;
	RT_ReleaseDifference				: R_TRIG;
	RT_ChooseSide						: R_TRIG;
	mxEmptying							: BOOL;
	LastProductWasA						: BOOL;
	SR_SprayBStartsMovingTrNotClear: SR;
	FT_StartFormingAside				: F_TRIG;
	FT_StartFormingBside				: F_TRIG;
	RT_StartFormingASide				: R_TRIG;
	RT_StartFormingBSide				: R_TRIG;
	T_IMDKickoffs: TON;
	KickoffsIMD: REAL;
	TotalKickoffsB: REAL;
	TotalKickoffsA: REAL;
	KoB: REAL;
	KoA: REAL;
	Calc_TotalTimeA	: BOOL;
	Calc_TotalTimeB	: BOOL;
	
	CalculateMaxKO			: FB_CalculateMaxKO;
	NewValue_MaxKO_A		: BOOL;
	NewValue_MaxKO_B		: BOOL;
	NewValue_MaxKO_Forming	: BOOL;
	TopLateTimeA: TIME;
	TopLateTimeB: TIME;
	TransferLateTimeA: TIME;
	TransferLateTimeB: TIME;
	RT_StartFormingA: R_TRIG;
	RT_StartFormingB: R_TRIG;
	mxMachineComesFromPause: BOOL;
	RT_FormingToPause: R_TRIG;
	mxFormingIsPaused: BOOL;
	mxFormingForASideStarted: BOOL;
	mxFormingForBSideStarted: BOOL;
	T_Unpause250ms: TON;
	T_Unpause500ms: TON;
END_VAR

VAR_TEMP
	RT_PauseReqZone5: R_TRIG;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[RT_ErrorInit(CLK:= mxErrorInit AND mxCycleBusy);
IF RT_ErrorInit.Q THEN
	mxStopDirect:= TRUE;
END_IF

FT_EnableASide(CLK:= MachParameters.EnableEamcSideA);
FT_EnableBSide(CLK:= MachParameters.EnableEamcSideB);

// IF Bside is not enabeld, and enable of aside is taken away, set A side again automaticaly
IF NOT MachParameters.EnableEamcSideB AND FT_EnableASide.Q AND NOT MachParameters.CommisioningMode THEN
	MachParameters.EnableEamcSideA :=TRUE;
END_IF

// IF Aside is not enabeld, and enable of Bside is taken away, set B side again automaticaly
IF NOT MachParameters.EnableEamcSideA AND FT_EnableBSide.Q AND NOT MachParameters.CommisioningMode THEN
	MachParameters.EnableEamcSideB := TRUE;
END_IF

// Automaticaly log out off commisioning mode after 2hours.
T_StopCommisioningMode(IN:=MachParameters.CommisioningMode, PT:=T#120M);
IF T_StopCommisioningMode.Q THEN
	MachParameters.CommisioningMode := FALSE;
END_IF

IF 	ProductForming.MaxTimeSingleKO = 0 THEN
	CalculateMaxKO.Value_Forming 	:= 0;
ELSE
	CalculateMaxKO.Value_Forming 	:= (60000 / ProductForming.MaxTimeSingleKO);	
END_IF

CalculateMaxKO(
	init			:= NOT mxAutoMode OR mxInitBusy OR mxInPause,
	AEnabled		:= mxSideAEnabled,
	BEnabled		:= mxSideBEnabled,
	CLK_A 			:= NewValue_MaxKO_A,
	CLK_B 			:= NewValue_MaxKO_B,
	CLK_Forming		:= NewValue_MaxKO_Forming,
	Value_A 		:= TopMoldA.MaxDryingSingleKO * 2,
	Value_B 		:= TopMoldB.MaxDryingSingleKO * 2,
);

(* Actions *)
Error();
ErrorsTemperature();
Init();
Cycle();
Objects();

]]></ST>
    </Implementation>
    <Action Name="Cycle" Id="{5dfdbb51-0792-47a5-8a31-f7b888b74536}">
      <Implementation>
        <ST><![CDATA[(*StateChange (Transition)  Signalgeneration*)
mxCycleTransitionState:=(miCycleState<>miCycleOldstate);
(*State text*)
sCycleStateText:=sCycleStateTextDef[miCycleState];
(*Timeout Watchdog for Statemachine*)
mxCycleTimeoutEnable:=NOT (miCycleState=0) AND NOT mxReset;

CycleTimeout(IN:=mxCycleTimeoutEnable, PT:=tCycleStateTimeouts[miCycleState] );
CycleTimeOutUpFlank(CLK:=CycleTimeout.Q );
miCycleOldstate:=miCycleState;

(*Set Errorbit when Raising edge of Timeout has been detected*)
IF CycleTimeOutUpFlank.Q THEN
	exCycleTimeOut:=TRUE; 			(* 1 Timeout for the whole programcycle *)
END_IF

(*Function to reset the Statemachine*)
IF mxResetCycleState THEN
	mxInPause := FALSE;
	mxResetCycleState:= FALSE;
	miCycleState:=0;
	miCycleOldstate:=miCycleState;
	mxCycleTransitionState:=FALSE;

	TopMoldA.mxResetCycleState:= TRUE;
	TopMoldB.mxResetCycleState:= TRUE;
	BottomMoldA.mxResetCycleState:= TRUE;
	BottomMoldB.mxResetCycleState:= TRUE;
	TransferMold.mxResetCycleState:= TRUE;
	ProductForming.mxResetCycleState:= TRUE;
	
	mxInitialized := FALSE;
	mxStartCycle:= FALSE;
	mxStopCycle:= FALSE;
	mxStopCycleEmpty := FALSE;
	mxStopDirect:= FALSE;
	mxMachineComesFromPause := FALSE;

	ProductDryingAtSideA := FALSE;
	ProductDryingAtSideB := FALSE;
	mxFormingIsPaused := FALSE;
	mxFormingForASideStarted := FALSE;
	mxFormingForBSideStarted := FALSE;

	BottomMoldA.sgSample := BottomMoldB.sgSample := mxSample :=FALSE;
	
	KickoffsIMD := TIME_TO_REAL(T_IMDKickoffs.ET);
	T_IMDKickoffs.IN:=FALSE;
	
	T_Unpause250ms.IN :=FALSE;
	T_Unpause500ms.IN :=FALSE;	
	
	miStopState:= 0;
END_IF

(*Definition State has Error*)
mxCycleHasError:=FALSE;

T_Unpause250ms(IN:=, PT:=T#500MS);
T_Unpause500ms(IN:=, PT:=T#1000MS);

// Only switch sides when machine stands still.
IF NOT mxCycleBusy THEN 
	mxSideAEnabled:= MachParameters.EnableEamcSideA;
	mxSideBEnabled:= MachParameters.EnableEamcSideB;
END_IF

{region "Code to determine: Continue with A /B"}
RT_ChooseSide(CLK:=(miCycleState = 12));
RT_StartFormingA(CLK:= mxStartFormingA AND miCycleState = 12 AND mxSideAEnabled);
RT_StartFormingB(CLK:= mxStartFormingB AND miCycleState = 12 AND mxSideBEnabled);
RT_FormingToPause(CLK:=ProductForming.sgFormingToPause);

IF RT_FormingToPause.Q THEN
	mxFormingIsPaused := TRUE;
END_IF

IF RT_StartFormingA.Q OR RT_StartFormingB.Q AND NOT mxMachineComesFromPause  THEN			// <- Needs to b a R_TRIG	
	IF mxSideAEnabled AND NOT mxSideBEnabled THEN		// Only A enabled
		ContinueWithA := TRUE;
		ContinueWithB := False;
	ELSIF NOT mxSideAEnabled AND mxSideBEnabled THEN 	// Only B enabled
		ContinueWithA := FALSE;
		ContinueWithB := True;
	ELSIF mxSideAEnabled AND mxSideBEnabled THEN		// A AND B enabled
		IF mxStartFormingA AND NOT mxStartFormingB THEN
			ContinueWithA := TRUE;
			ContinueWithB := FALSE;
		ELSIF NOT mxStartFormingA AND  mxStartFormingB THEN
			ContinueWithA := FALSE;
			ContinueWithB := TRUE;
		ELSE
			IF ContinueWithA THEN							// when busy with A, new carton will be B
				ContinueWithA := FALSE;
				ContinueWithB := TRUE;
			ELSIF ContinueWithB THEN						// When Busy with B, New carton will be A
				ContinueWithA := TRUE;
				ContinueWithB := FALSE;
			ELSE											// When machine is empty new carton will be A
				ContinueWithA := TRUE;
				ContinueWithB := FALSE;
			END_IF
		END_IF
	END_IF
ELSIF mxMachineComesFromPause AND mxFormingForASideStarted AND RT_ChooseSide.Q THEN
	ContinueWithA := TRUE;
	ContinueWithB := FALSE;
ELSIF mxMachineComesFromPause AND mxFormingForBSideStarted AND RT_ChooseSide.Q THEN
	ContinueWithA := FALSE;
	ContinueWithB := TRUE;
END_IF

{endregion}

{region "Reset communication signals with SpeedControl"}
	FT_StartFormingAside(CLK:= mxStartFormingA);
	FT_StartFormingBside(CLK:= mxStartFormingB);
	
	IF FT_StartFormingAside.Q THEN
		mxFormingA_Ready := FALSE;
	END_IF
	IF FT_StartFormingBside.Q THEN
		mxFormingB_Ready := FALSE;
	END_IF
{endregion}
	
{region "Determine which signaled for release first."}
	T_TransferReleasedBottom(IN:=, PT:=T#600S);
	T_TopReleasedBottom(IN:=, PT:=T#600S);
	T_TopReleasedBottomA(IN:=, PT:=T#600S);
	T_TopReleasedBottomB(IN:=, PT:=T#600S);
	RT_ReleaseDifference(CLK:=(NOT (miCycleState = 12)), Q=> );

	IF miCycleState >= 9 AND miCycleState <= 12 THEN //Step 12
		IF TransferMold.sgTrReleaseBmMoveIn THEN
			T_TransferReleasedBottom.IN:=TRUE;
		END_IF
		
		IF TopMoldA.SgTmIsUp OR TopMoldB.SgTmIsUp THEN
			T_TopReleasedBottom.IN:=TRUE;		
		END_IF
		
		IF TopMoldA.SgTmIsUp THEN
			T_TopReleasedBottomA.IN:=TRUE;
			Calc_TotalTimeA	:= TRUE;	
		END_IF
		IF TopMoldB.SgTmIsUp THEN
			T_TopReleasedBottomB.IN:=TRUE;
			Calc_TotalTimeB	:= TRUE;		
		END_IF
		
	END_IF
	
	IF RT_ReleaseDifference.Q THEN
		TransferLateTimeA:=T#0MS;
		TransferLateTimeB:=T#0MS;
		TopLateTime:=T#0MS;
		TopMoldA.TopLateTime := 0;
		TopMoldB.TopLateTime := 0;
		
		// old is only an example now and can be removed later
		//IF T_TransferReleasedBottom.ET > T_TopReleasedBottom.ET THEN
		//	TransferLateTime := T_TransferReleasedBottom.ET;
		//ELSIF T_TopReleasedBottom.ET > T_TransferReleasedBottom.ET THEN
		//	TopLateTime := T_TopReleasedBottom.ET;
		//END_IF	
			
		IF Calc_TotalTimeA THEN
			// Update HMI
			TopLateTimeA := T_TopReleasedBottomA.ET;
			TransferLateTimeA := T_TransferReleasedBottom.ET;

			// Needed for speed control
			TopMoldA.TopLateTime := TIME_TO_REAL(T_TopReleasedBottomA.ET);
			Calc_TotalTimeA := FALSE;
			NewValue_MaxKO_A := TRUE;
		END_IF
		IF Calc_TotalTimeB THEN
			// Update HMI
			TopLateTimeB := T_TopReleasedBottomB.ET;
			TransferLateTimeB := T_TransferReleasedBottom.ET;
			
			// Needed for speed control
			TopMoldB.TopLateTime := TIME_TO_REAL(T_TopReleasedBottomB.ET);
			Calc_TotalTimeB := FALSE;
			NewValue_MaxKO_B := TRUE;
		END_IF
		
		T_TransferReleasedBottom.IN:=FALSE;	
		T_TopReleasedBottom.IN:=FALSE;
		T_TopReleasedBottomA.IN:=FALSE;
		T_TopReleasedBottomB.IN:=FALSE;
	END_IF	

{endregion}

// Start forming from speedcontrol, only hapens during normal production.
RT_StartFormingASide(CLK:=mxStartFormingA  AND mxSideAEnabled);
RT_StartFormingBSide(CLK:=mxStartFormingB AND mxSideBEnabled);
IF RT_StartFormingASide.Q THEN
	mxFormingForASideStarted := TRUE;	
END_IF
IF RT_StartFormingBSide.Q THEN
	mxFormingForBSideStarted := TRUE;	
END_IF

(*IF ((miCyclestate = 1) AND RT_StartFormingASide.Q OR RT_StartFormingBSide.Q) OR
	((miCyclestate >= 4) AND (miCyclestate <= 12) AND ((RT_StartFormingASide.Q AND mxGantryA_AtBelt) OR (RT_StartFormingBSide.Q AND mxGantryB_AtBelt))) THEN*)
IF ((miCyclestate >= 4) AND (miCyclestate <= 12) OR (miCyclestate = 1)) AND RT_StartFormingASide.Q OR RT_StartFormingBSide.Q THEN
	IF NOT mxEmptying AND NOT mxFormingIsPaused  THEN	// emptying added by Bateu. // mxFormingIsPaused added by Mazee
		ProductForming.M_StartCycle();
	END_IF
END_IF


T_IMDKickoffs(PT:=T#600S);

(*Cycle State's*)
CASE miCycleState OF
	0:	// (P)  Wait for start 
		IF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF mxStartCycle THEN
			mxStartCycle:= FALSE;
			miStopState:= 0;
			mxIsEmpty:= FALSE;
			mxEmptying:=FALSE;
			mxStopBeforeSCstarted := FALSE;
			mxFormingForASideStarted := FALSE;
			mxFormingForBSideStarted := FALSE;	
			
			IF mxSideAEnabled AND mxSideBEnabled THEN
				ContinueWithB := TRUE;
				ContinueWithA := FALSE;
			ELSIF mxSideAEnabled AND NOT mxSideBEnabled THEN		// Only A enabled
				ContinueWithA := TRUE;
				ContinueWithB := False;
			ELSIF NOT mxSideAEnabled AND mxSideBEnabled THEN 	// Only B enabled
				ContinueWithA := FALSE;
				ContinueWithB := True; 
			END_IF			
			
			TransferMold.M_StartCycle();
			
			IF mxSideAEnabled THEN 
				TopMoldA.M_StartCycle(); 
				BottomMoldA.M_StartCycle();
			END_IF
			IF mxSideBEnabled THEN 
				TopMoldB.M_StartCycle(); 
				BottomMoldB.M_StartCycle();
			END_IF
			
			miCycleState:= 1;
		END_IF
		
	1:	// (NP) Wait for product forming ready
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF NOT ProductForming.mxCycleBusy AND (mxStopCycleEmpty OR mxStopCycle) THEN
			mxStopBeforeSCstarted := TRUE;
			mxStopCycleEmpty := FALSE;
			mxStopCycle:= FALSE;
			miCycleState:= 0;		
		ELSIF ProductForming.SgTransferToDownForming THEN	// Signal the transfer to move down
			ProductForming.SgTransferToDownForming :=FALSE;
			TransferMold.sgMoveDownToFormingPos:= TRUE;
			miCycleState:= 2;	
		END_IF
		
	2:  // (NP) Wait for transfermold is down at forming pos
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF TransferMold.sgTrAtFormingPos THEN	
			TransferMold.sgTrAtFormingPos := FALSE;
			ProductForming.sgTransferIsDown:= TRUE;		// ProductForming.TransferAtStopVacuumForming
			miCycleState:= 3;
		END_IF
		
	3:  // (NP) Wait for productforming time closed and then move transfer up
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF ProductForming.sgTransferToMoveUp THEN	// ClosedDelayTimeElapsed
			ProductForming.sgTransferToMoveUp := FALSE;
			TransferMold.sgMoveUp:= TRUE;
			miCycleState:= 4;
		END_IF
	
	4:	// (P)  Move Transfermold up and at certain point make a new porduct (only if emty machine is not active).	
		ProductOnTopMoldA := FALSE;					// These bits indicate weather it is the first run for a certain side.
		ProductOnTopMoldB := FALSE;
		ProductDryingAtSideA	  := FALSE;			// These bits indicate if a side is empty
		ProductDryingAtSideB	  := FALSE;
		
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF TransferMold.sgTrReleaseBmMoveIn AND mxStartFormingA AND mxSideAEnabled THEN
			ContinueWithA := TRUE;
			mxFormingA_Ready := TRUE;
			TransferMold.sgTrReleaseBmMoveIn:= FALSE;
			BottomMoldA.sgMoveIn:= TRUE;
			BottomMoldA.mxProductOnTopMold:= ProductOnTopMoldA;	// Skip step 5 (move top mold up, because at a fresh start.
			BottomMoldA.sgSample := mxSample;					// If Sample is '1', block the bottommold in vacuum.	
			miCycleState := 6;									// topmold is allready up. Just continue with the bottommold in movement.
		ELSIF TransferMold.sgTrReleaseBmMoveIn AND mxStartFormingB AND mxSideBEnabled THEN
			ContinueWithB := TRUE;
			mxFormingB_Ready := TRUE;
			TransferMold.sgTrReleaseBmMoveIn:= FALSE;
			BottomMoldB.mxProductOnTopMold:= ProductOnTopMoldB;
			BottomMoldB.sgMoveIn:= TRUE;
			BottomMoldB.sgSample := mxSample;								// If Sample is '1', block the bottommold in vacuum.	
			miCycleState := 6;
		END_IF										
		
		//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\ Main program loop			
	5:	// (NP) Obsolete Step.
		miCycleState:= 6;
	6:	// (P)  Move bottom mold A / B in	
		T_IMDKickoffs.IN:=TRUE;
	
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;	
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF BottomMoldA.SgBottomIsIn AND ContinueWithA THEN
			BottomMoldA.SgBottomIsIn := FALSE; 
			TransferMold.sgMoveToTransferPosA:= TRUE;
			miCycleState:= 7;
		ELSIF BottomMoldB.SgBottomIsIn AND ContinueWithB THEN
			BottomMoldB.SgBottomIsIn := FALSE; 
			TransferMold.sgMoveToTransferPosB:= TRUE;
			miCycleState:= 7;
		END_IF

	7:	// (P)  Move Transfer mold up
			
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;	
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF Transfermold.sgTransferIsUpMoveOut AND ContinueWithA THEN
			Transfermold.sgTransferIsUpMoveOut := FALSE; 
			TransferMold.sgMoveToTransferPosA:= FALSE;
			BottomMoldA.sgMoveOut:= TRUE;
			miCycleState:= 8;
		ELSIF Transfermold.sgTransferIsUpMoveOut AND ContinueWithB THEN
			Transfermold.sgTransferIsUpMoveOut := FALSE;
			TransferMold.sgMoveToTransferPosB:= FALSE; 
			BottomMoldB.sgMoveOut:= TRUE;
			miCycleState:= 8;
		END_IF
		
	8:	// (P)  Move bottom Mold A / B Out
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF BottomMoldA.SgBottomIsOut AND ContinueWithA THEN
			BottomMoldA.SgBottomIsOut := FALSE; 
			TopMoldA.sgMoveDown:= TRUE;	
			TransferMold.sgBottomMoldAIsOut := TRUE;		
			miCycleState:= 9;
		ELSIF BottomMoldB.SgBottomIsOut AND ContinueWithB THEN
			BottomMoldB.SgBottomIsOut := FALSE; 
			TopMoldB.sgMoveDown:= TRUE;	
			TransferMold.sgBottomMoldBIsOut := TRUE;		
			miCycleState:= 9;		
		END_IF

	9:	// (P)  Move Topmold A / B down, Wait for productForming ready
		mxEmptying:=mxStopCycleEmpty;		// Set a bit to show the machine is emptying. This ensures that the transfer loses its last product on the bottommold.
		mxSample :=FALSE;
		
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF (ProductForming.SgTransferToDownForming OR (mxEmptying AND NOT ProductForming.mxCycleBusy)) AND ContinueWithA THEN	
			ProductForming.SgTransferToDownForming:=FALSE; 
			ProductDryingAtSideA := TRUE; //NOT BottomMoldA.sgSample;
			BottomMoldA.sgSample := FALSE;

			IF mxEmptying AND NOT ProductForming.mxCycleBusy THEN
				IF mxSideAEnabled AND mxSideBEnabled THEN
					ContinueWithA := NOT ContinueWithA;
					ContinueWithB := NOT ContinueWithB;
				END_IF
				miCycleState:= 13;
			ELSE
				TransferMold.sgMoveDownToFormingPos:= TRUE;
				miCycleState:= 10;
			END_IF
		ELSIF (ProductForming.SgTransferToDownForming OR (mxEmptying AND NOT ProductForming.mxCycleBusy)) AND ContinueWithB THEN	
			ProductForming.SgTransferToDownForming:=FALSE; 
			ProductDryingAtSideB := TRUE; //NOT BottomMoldB.sgSample;
			BottomMoldB.sgSample := FALSE;
			IF mxEmptying AND NOT ProductForming.mxCycleBusy THEN
				IF mxSideAEnabled AND mxSideBEnabled THEN
					ContinueWithA := NOT ContinueWithA;
					ContinueWithB := NOT ContinueWithB;
				END_IF
				miCycleState:= 13;
			ELSE
				TransferMold.sgMoveDownToFormingPos:= TRUE;
				miCycleState:= 10;
			END_IF				
		END_IF																									
			
	10: // (NP) Wait for transfermold is down at forming pos !! Meanwhile, at top of cycle, new continue with A/B is set.
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF TransferMold.sgTrAtFormingPos THEN		// No selection is side is done cause its irrelavant here.
			Transfermold.sgTrAtFormingPos := FALSE;
			ProductForming.sgTransferIsDown:= TRUE;
			miCycleState:= 11;
		END_IF

	11: // (NP) Wait for productforming after blowOff is on
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF ProductForming.sgTransferToMoveUp THEN	// ClosedDelayTimeElapsed
			ProductForming.sgTransferToMoveUp := FALSE;
			TransferMold.sgMoveUp:= TRUE;
			miCycleState:= 12;
		END_IF

	12:	// (P)  Move Transfermold up  -> P by bateu 20190408
		mxEmptying:=mxStopCycleEmpty;		// Set a bit to show the machine is emptying. This ensures that the transfer loses its last product on the bottommold.
		
		
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF TransferMold.sgTrReleaseBmMoveIn AND (TopmoldA.SgTmIsUp OR NOT ProductDryingAtSideA) AND ContinueWithA THEN // A side = next
			mxFormingIsPaused := FALSE;
			mxFormingForASideStarted := FALSE;
			mxMachineComesFromPause := FALSE;	
			
			mxFormingA_Ready := TRUE;	//Used to reset start forming bit
			mxFormingB_Ready := TRUE;	//Used to reset start forming bit
	
			TransferMold.sgTrReleaseBmMoveIn:= FALSE;		
			BottomMoldA.sgMoveIn:= TRUE;
			BottomMoldA.sgSample := mxSample;								// If Sample is '1', block the bottommold in vacuum.
			ProductOnTopMoldA := TRUE; 										// Next time this step is executed, the topmold will indicate it has a product
			BottomMoldA.mxProductOnTopMold:= ProductDryingAtSideA;
			miCycleState:= 6;	
			
			KickoffsIMD := TIME_TO_REAL(T_IMDKickoffs.ET);
			T_IMDKickoffs.IN:=FALSE;				
			TotalKickoffsA := KickoffsIMD + Main.ProductHandling.GantryA.GantrySingleKo;		
		ELSIF TransferMold.sgTrReleaseBmMoveIn AND (TopMoldB.SgTmIsUp OR NOT ProductDryingAtSideB) AND ContinueWithB THEN 		// B Side = next
			mxFormingIsPaused := FALSE;
			mxFormingForBSideStarted := FALSE;
			mxMachineComesFromPause := FALSE;	
			
			mxFormingA_Ready := TRUE;	//Used to reset start forming bit
			mxFormingB_Ready := TRUE;	//Used to reset start forming bit
			
			TransferMold.sgTrReleaseBmMoveIn:= FALSE;		
			BottomMoldB.sgMoveIn:= TRUE;
			BottomMoldB.sgSample := mxSample;								// If Sample is '1', block the bottommold in vacuum.		
			ProductOnTopMoldB := TRUE; 										// Next time this step is executed, the topmold will indicate it has a product
			BottomMoldB.mxProductOnTopMold:= ProductDryingAtSideB;
			miCycleState:= 6;

			KickoffsIMD := TIME_TO_REAL(T_IMDKickoffs.ET);
			T_IMDKickoffs.IN:=FALSE;		
			TotalKickoffsB := KickoffsIMD + Main.ProductHandling.GantryB.GantrySingleKo;
		END_IF

		//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\//\\//\\/\\//\\//\\ Normal production loop -> 6		

	13:	// (P)  Move topmold A / B up 
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF TopMoldA.SgTmIsUp AND ContinueWithA THEN
			BottomMoldA.sgMoveIn:= TRUE;
			BottomMoldA.mxProductOnTopMold:= TRUE;
			miCycleState:= 14;
		ELSIF TopMoldB.SgTmIsUp AND ContinueWithB THEN
			BottomMoldB.sgMoveIn:= TRUE;
			BottomMoldB.mxProductOnTopMold:= TRUE;
			miCycleState:= 14;
		END_IF
		
	14: // (P)  Move bottomMold in to fill takeoutunit with last product on this side
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF BottomMoldA.SgBottomIsIn AND ContinueWithA THEN
			BottomMoldA.SgBottomIsIn := FALSE; 
			BottomMoldA.sgMoveOut:= TRUE;	
			miCycleState:= 15;
		ELSIF BottomMoldB.SgBottomIsIn AND ContinueWithB THEN
			BottomMoldB.SgBottomIsIn := FALSE; 
			BottomMoldB.sgMoveOut:= TRUE;	
			miCycleState:= 15;
		END_IF 
		
	15: // (P)  Move bottommold out to the gantries, and wait for last product on this side to be picked up
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStopCycle THEN
			mxStopCycle:= FALSE;
			miStopState:= miCycleState;
			miCycleState:= 19;
		ELSIF BottomMoldA.SgBottomIsOut AND ContinueWithA THEN
			BottomMoldA.SgBottomIsOut := FALSE;
			TopMoldA.mxMoveUp:= TRUE;
			ContinueWithA := FALSE;
			ContinueWithB := TRUE;
			ProductDryingAtSideA := FALSE;
			
			LastProductWasA := TRUE;
			
			IF NOT ProductDryingAtSideA AND NOT ProductDryingAtSideB THEN
				miCycleState:=16;
			ELSE	
				miCycleState:= 13;
			END_IF
		ELSIF BottomMoldB.SgBottomIsOut AND ContinueWithB THEN
			BottomMoldB.SgBottomIsOut := FALSE;
			TopMoldB.mxMoveUp:= TRUE;
			ContinueWithA := TRUE;
			ContinueWithB := FALSE;
			ProductDryingAtSideB := FALSE;
			
			LastProductWasA := FALSE;
			
			IF NOT ProductDryingAtSideA AND NOT ProductDryingAtSideB THEN
				miCycleState:=16;
			ELSE	
				miCycleState:= 13;
			END_IF
		END_IF 

	16:	// (NP) Machine is empty, Wait until Gantry picked up Product A and B 
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF (LastProductWasA AND BottommoldA.mxHorCilIsIn AND BottomMoldA.mxGantryPickedUpProduct) OR
				(NOT LastProductWasA AND BottommoldB.mxHorCilIsIn AND BottomMoldB.mxGantryPickedUpProduct) THEN 	
			mxIsEmpty := TRUE;
			mxEmptying := FALSE;
			mxStopCycleEmpty := FALSE;
	
			ProductOnTopMoldA := FALSE;
			ProductOnTopMoldB := FALSE;
			
			miStopState:= miCycleState;
			miCycleState:= 17;
		END_IF
	
	17: // [Emptying] Stopping sub parts
		mxStopCycle:= FALSE;

		IF TopMoldA.mxCycleBusy THEN TopMoldA.M_EmptyMachine(); END_IF
		IF TopMoldB.mxCycleBusy THEN TopMoldB.M_EmptyMachine(); END_IF
		IF TransferMold.mxCycleBusy THEN TransferMold.M_EmptyMachine(); END_IF
		IF BottomMoldA.mxCycleBusy THEN	BottomMoldA.M_EmptyMachine(); END_IF
		IF BottomMoldB.mxCycleBusy THEN	BottomMoldB.M_EmptyMachine(); END_IF
		IF ProductForming.mxCycleBusy THEN ProductForming.M_EmptyMachine(); END_IF

		IF TopMoldA.mxCycleBusy THEN TopMoldA.M_StopCycle(); END_IF
		IF TopMoldB.mxCycleBusy THEN TopMoldB.M_StopCycle(); END_IF
		IF TransferMold.mxCycleBusy THEN TransferMold.M_StopCycle(); END_IF
		IF BottomMoldA.mxCycleBusy THEN	BottomMoldA.M_StopCycle(); END_IF
		IF BottomMoldB.mxCycleBusy THEN	BottomMoldB.M_StopCycle(); END_IF
		IF ProductForming.mxCycleBusy THEN ProductForming.M_StopCycle(); END_IF

		miCycleState:= 0;
		
	18: // [Emptying] Check if everything has stopped.
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;	
			miCycleState:=25;
		ELSIF NOT TopMoldA.mxCycleBusy AND NOT TopMoldB.mxCycleBusy AND NOT TransferMold.mxCycleBusy AND NOT BottomMoldA.mxCycleBusy
			AND NOT BottomMoldB.mxCycleBusy AND NOT ProductForming.mxCycleBusy THEN

			BottomMoldA.mxEmptyMachine:= FALSE;
			BottomMoldB.mxEmptyMachine:= FALSE;
			TransferMold.mxStartProductForming := FALSE;			
			miCycleState:= 0;
		END_IF
		
	19: // [Pausing] stopping sub objects. (to pause mode)
		IF mxSideAEnabled THEN
			TopMoldA.M_StopCycle(); 
			BottomMoldA.M_StopCycle();
		END_IF
		IF mxSideBEnabled THEN
			TopMoldB.M_StopCycle(); 
			BottomMoldB.M_StopCycle();
		END_IF
		TransferMold.M_StopCycle(); 
		ProductForming.M_StopCycle(); 
		
		miCycleState := 20;
	
	20: // [Pausing] Hydraulics
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF NOT TopMoldA.mxCycleBusy AND NOT TopMoldB.mxCycleBusy AND NOT TransferMold.mxCycleBusy AND NOT ProductForming.mxCycleBusy THEN			
			IF HydraulicsMain.mxCycleBusy THEN HydraulicsMain.M_StopCycle(); END_IF// Force Hydraulics to pause state 
			miCycleState := 21;
		END_IF;	
		
	21: // [Paused] -> restart hydraulics at mxstartcycle.
		TransferMold.sgSample := mxSample; 	// shut of vacuum of transfer when taking a sample.
		
		KickoffsIMD := TIME_TO_REAL(T_IMDKickoffs.ET);
		T_IMDKickoffs.IN:=FALSE;
	
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF mxStartCycle THEN
			mxStartCycle:= FALSE;
			HydraulicsMain.M_StartCycle();
			miCycleState:= 22;
		END_IF;
	
	22: // [Restart] Restart sub parts 

	
		IF mxStopDirect THEN
			mxStopDirect:= FALSE;
			miCycleState:=25;
		ELSIF HydraulicsMain.mxHydraulicsReady THEN
			mxStartCycle:= FALSE;
			T_Unpause250ms.IN:= TRUE;
			T_Unpause500ms.IN:=TRUE;
			
			IF mxSideAEnabled THEN							// Restart immidiatly
				TopmoldA.sgSample := mxSample;
				TopMoldA.M_StartCycle();
				BottomMoldA.M_StartCycle();
			END_IF
			IF mxSideBEnabled AND T_Unpause250ms.Q THEN		// Restart after 250ms to prevent hammering
				TopmoldB.sgSample := mxSample;
				TopMoldB.M_StartCycle();
				BottomMoldB.M_StartCycle();
				T_Unpause250ms.in := FALSE;
			END_IF
			
			IF T_Unpause500ms.q THEN						// Restart after 500ms to continue production
				TransferMold.M_StartCycle();		
				ProductForming.M_StartCycle();
				T_Unpause500ms.in := FALSE;
				
				mxMachineComesFromPause := TRUE;
				miCycleState:= miStopState;
			END_IF
		END_IF;
		
	25: // Stop Direct 
		mxStartCycle:= FALSE;
		mxStopCycle:= FALSE;
		mxStopDirect:= FALSE;
		miStopState:= 0;
		mxInitialized:= FALSE;
		mxStopCycleEmpty := FALSE;
		mxEmptying := FALSE;
		ProductOnTopMoldA := FALSE;
		ProductOnTopMoldB := FALSE;
		mxMachineComesFromPause := FALSE;
		mxFormingIsPaused := FALSE;
		mxFormingForASideStarted := FALSE;
		mxFormingForBSideStarted := FALSE;

		ProductDryingAtSideA	  := FALSE;
		ProductDryingAtSideB	  := FALSE;
		
		T_Unpause250ms.IN :=FALSE;
		T_Unpause500ms.IN :=FALSE;	
		
		BottomMoldA.sgSample := BottomMoldB.sgSample := mxSample :=FALSE;
		
		IF HydraulicsMain.mxCycleBusy THEN HydraulicsMain.m_StopDirect(); END_IF
		IF TopMoldA.mxCycleBusy THEN TopMoldA.M_StopDirect(); END_IF
		IF TopMoldB.mxCycleBusy THEN TopMoldB.M_StopDirect(); END_IF
		IF TransferMold.mxCycleBusy THEN TransferMold.M_StopDirect(); END_IF
		IF BottomMoldA.mxCycleBusy THEN	BottomMoldA.M_StopDirect(); END_IF
		IF BottomMoldB.mxCycleBusy THEN	BottomMoldB.M_StopDirect(); END_IF
		IF ProductForming.mxCycleBusy THEN ProductForming.M_StopDirect(); END_IF

		KickoffsIMD := TIME_TO_REAL(T_IMDKickoffs.ET);
		T_IMDKickoffs.IN:=FALSE;
		
		miCycleState:= 0;
END_CASE

mxCycleBusy:= miCycleState<>0 AND NOT (miCycleState=21);
mxInPause:=	miCycleState=21  
			AND ((TopMoldA.mxInPause AND BottomMoldA.mxInPause) OR NOT mxSideAEnabled)
			AND ((TopMoldB.mxInPause AND BottomMoldB.mxInPause) OR NOT mxSideBEnabled)
			AND ProductForming.mxInPause AND TransferMold.mxInPause;
			
// Caclulate kickoffs for speed control		
IF TotalKickoffsA <> 0 THEN KoA := 60000/TotalKickoffsA; END_IF
IF TotalKickoffsB <>0 THEN KoB := 60000/TotalKickoffsB; END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="Error" Id="{626e1ae0-4c16-470d-9902-01e8e2d7837a}">
      <Implementation>
        <ST><![CDATA[
(********** RED HOT SAFETY RULES ************)
mxSafetyRulesEnabled := ((mxInitialized AND mxAutoMode) OR (NOT mxAutomode)) AND NOT MachParameters.CommisioningMode;

	(* Transfer Mold Up or Down 	Bottom Drying Molds are In or Out / Spray bar is at one of the rest positions *)	
	SR_TrMoldIsMovingBoMoldANotInPos(SET1:=mxSafetyRulesEnabled AND  (TransferMold.mxCilIsMovingIn OR TransferMold.mxCilIsMovingOut) AND 
	(NOT BottomMoldA.mxCilIsOut AND NOT BottomMoldA.mxCilIsIn) AND (TransferMold.ActualPosition < MachParameters.MinimumTransferPosRHSR) , RESET:= mxReset, Q1=> Errors.RH_TrMoldIsMovingBoMoldANotInPos);
	
	SR_TrMoldIsMovingBoMoldBNotInPos(SET1:= mxSafetyRulesEnabled AND (TransferMold.mxCilIsMovingIn OR TransferMold.mxCilIsMovingOut) AND
	(NOT BottomMoldB.mxCilIsOut AND NOT BottomMoldB.mxCilIsIn) AND (TransferMold.ActualPosition < MachParameters.MinimumTransferPosRHSR), RESET:= mxReset, Q1=> Errors.RH_TrMoldIsMovingBoMoldBNotInPos);

	(*Transfermold position is to far down while spraybar is not yet in restposition.*)
	SR_TrMoldIsMovingSprayBNotInPos(SET1:= mxSafetyRulesEnabled AND (TransferMold.mxCilIsMovingOut AND (TransferMold.ActualPosition < MachParameters.MinimumTrDownSprayReleasePosRHSR) AND NOT ProductForming.mxSprayBarAtRestPos),
	RESET:= mxReset, Q1=> Errors.RH_TrMoldIsMovingSprayBNotInPos);
	
	(*Spraybar starts moving while tranfefermold is still down or close to forming.*)
	//SR_SprayBStartsMovingTrNotClear(SET1:=mxSafetyRulesEnabled AND 
	//(TransferMold.mxCilIsMovingIn AND (TransferMold.ActualPosition < MachParameters.MinimumTrUpSprayReleasePosRHSR) AND NOT ProductForming.mxSprayBarAtRestPos),
	//RESET:=mxReset, Q1=> ERrors.RH_SprayBIsMovingTrNotClear);
	
	// first window
	SR_SprayBStartsMovingTrNotClear(SET1:=mxSafetyRulesEnabled AND 
	(TransferMold.mxCilIsMovingIn AND (TransferMold.ActualPosition < MachParameters.MinimumTrUpSprayReleasePosRHSR) AND 
	(ProductForming.SprayBarMotor.ActPosition >= (MachParameters.ProductForming.SprayBar.PositionRestBack + MachParameters.SprayBTrCollisionOffset))),
	RESET:=mxReset, Q1=> Errors.RH_SprayBIsMovingTrNotClear);	
	
	// 2nd window.
	(*SR_SprayBStartsMovingTrNotClear(SET1:=mxSafetyRulesEnabled AND 
	(TransferMold.mxCilIsMovingIn AND (TransferMold.ActualPosition < MachParameters.MinimumTrUpSprayReleasePosRHSR2) AND 
	(ProductForming.SprayBarMotor.ActPosition >= (MachParameters*)
	
	(* Top Drying Mold Down 	Corresponding Bottom Drying Mold Out *)
	SR_ToMoldAIsMovingBoMoldANotInPos(SET1:= mxSafetyRulesEnabled AND 
	(TopMoldA.mxCilIsMovingOut AND (TopMoldA.ActualPosition < (MachParameters.TopMoldA.PositionUpStop - Machparameters.MinimumTmAPosToAllowBmMove))) 
	AND NOT BottomMoldA.mxCilIsOut, 
		RESET:= mxReset, Q1=> Errors.RH_ToMoldAIsMovingBoMoldANotInPos);
	SR_ToMoldBIsMovingBoMoldBNotInPos(SET1:= mxSafetyRulesEnabled AND 
	(TopMoldB.mxCilIsMovingOut AND (TopMoldB.ActualPosition < (MachParameters.TopMoldB.PositionUpStop - Machparameters.MinimumTmBPosToAllowBmMove))) 
	AND NOT BottomMoldB.mxCilIsOut, 
		RESET:= mxReset, Q1=> Errors.RH_ToMoldBIsMovingBoMoldBNotInPos);
	
	(* Bottom Drying Mold In	Corresponding Top Drying Mold Up and Transfer Mold is Up *)
	SR_BoMoldAIsMovingToMoldANotInPos(SET1:= mxSafetyRulesEnabled AND (BottomMoldA.mxCilIsMovingIn OR BottomMoldA.mxCilIsMovingout) AND 
	(TopMoldA.ActualPosition < (MachParameters.TopMoldA.PositionUpStop - Machparameters.MinimumTmAPosToAllowBmMove)), 
		RESET:= mxReset, Q1=> Errors.RH_BoMoldAIsMovingToMoldANotInPos);
	SR_BoMoldAIsMovingTrMoldNotInPos(SET1:= mxSafetyRulesEnabled AND BottomMoldA.mxCilIsMovingIn AND (TransferMold.ActualPosition < MachParameters.MinimumTransferPosRHSR), 
		RESET:= mxReset, Q1=> Errors.RH_BoMoldAIsMovingTrMoldNotInPos);
	SR_BoMoldBIsMovingToMoldBNotInPos(SET1:= mxSafetyRulesEnabled AND (BottomMoldB.mxCilIsMovingIn OR BottomMoldB.mxCilIsMovingOut) AND
	(TopMoldB.ActualPosition < (MachParameters.TopMoldB.PositionUpStop - Machparameters.MinimumTmBPosToAllowBmMove)), 
		RESET:= mxReset, Q1=> Errors.RH_BoMoldBIsMovingToMoldBNotInPos);
	SR_BoMoldBIsMovingTrMoldNotInPos(SET1:= mxSafetyRulesEnabled AND BottomMoldB.mxCilIsMovingIn AND (TransferMold.ActualPosition < MachParameters.MinimumTransferPosRHSR), 
		RESET:= mxReset, Q1=> Errors.RH_BoMoldBIsMovingTrMoldNotInPos);
	
	(* Table Horizontal In	Corresponding Table Vertical is down *)	
	SR_TaOutHorAIsMovingVertIsNotDown(SET1:= mxSafetyRulesEnabled AND (NOT BottomMoldA.mxHorCilIsIn AND NOT BottomMoldA.mxVertCilIsOut), // in is down
		RESET:= mxReset, Q1=> Errors.RH_TaOutHorAIsMovingVertIsNotDown);
	SR_TaOutHorBIsMovingVertIsNotDown(SET1:= mxSafetyRulesEnabled AND (NOT BottomMoldB.mxHorCilIsIn AND NOT BottomMoldB.mxVertCilIsOut), // in is down
		RESET:= mxReset, Q1=> Errors.RH_TaOutHorBIsMovingVertIsNotDown);
// OR BottomMoldA.mxErrorStopinPos OR BottomMoldB.mxErrorStopinPos 
(**********************************************************************************************************)
mxErrorStopinPos:= TopMoldA.mxErrorStopinPos OR TopMoldB.mxErrorStopinPos OR BottomMoldA.mxErrorStopinPos OR BottomMoldB.mxErrorStopinPos 
	OR TransferMold.mxErrorStopinPos OR ProductForming.mxErrorStopinPos OR HydraulicsMain.mxErrorStopinPos;	
	
mxErrorInit:= TopMoldA.mxErrorInit OR TopMoldB.mxErrorInit Or BottomMoldA.mxErrorInit Or BottomMoldB.mxErrorInit
	OR TransferMold.mxErrorInit OR ProductForming.mxErrorInit OR HydraulicsMain.mxErrorInit 
	OR Errors.RH_BoMoldAIsMovingToMoldANotInPos OR Errors.RH_BoMoldAIsMovingTrMoldNotInPos OR Errors.RH_BoMoldBIsMovingToMoldBNotInPos OR Errors.RH_BoMoldBIsMovingTrMoldNotInPos
	OR Errors.RH_TaOutHorAIsMovingVertIsNotDown OR Errors.RH_TaOutHorBIsMovingVertIsNotDown OR Errors.RH_ToMoldAIsMovingBoMoldANotInPos OR Errors.RH_ToMoldBIsMovingBoMoldBNotInPos
	OR Errors.RH_TrMoldIsMovingBoMoldANotInPos OR Errors.RH_TrMoldIsMovingBoMoldBNotInPos OR Errors.RH_TrMoldIsMovingSprayBNotInPos OR Errors.RH_BotMoldAToCoolForTrMDown OR Errors.RH_SprayBIsMovingTrNotClear
	OR Errors.RH_BotMoldBToCoolForTrMDown OR Errors.TempDeviationToHighA[1] OR Errors.TempDeviationToHighA[2] OR Errors.TempDeviationToHighA[3] OR Errors.TempDeviationToHighA[4]
	OR Errors.TempDeviationToHighA[5] OR Errors.TempDeviationToHighA[6] OR Errors.TempDeviationToHighB[1] OR Errors.TempDeviationToHighB[2] OR Errors.TempDeviationToHighB[3]
	OR Errors.TempDeviationToHighB[4] OR Errors.TempDeviationToHighB[5] OR Errors.TempDeviationToHighB[6];
	]]></ST>
      </Implementation>
    </Action>
    <Action Name="ErrorsTemperature" Id="{2a486222-b7ba-4acc-b33c-977d4608339b}">
      <Implementation>
        <ST><![CDATA[(*Red hot safety regarding heating, block movement when top temperature deviates to much from bottom temperature*)
	SR_TempDeviationToHighA[1](SET1:=mxAutoMode AND
((BottomMoldA.HeatingZone[1].FB_Temperature.EngTempOut > TopMoldA.HeatingZone[1].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldA.HeatingZone[1].FB_Temperature.EngTempOut < TopMoldA.HeatingZone[1].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighA[1]);

	SR_TempDeviationToHighA[2](SET1:=mxAutoMode AND
((BottomMoldA.HeatingZone[2].FB_Temperature.EngTempOut > TopMoldA.HeatingZone[2].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldA.HeatingZone[2].FB_Temperature.EngTempOut < TopMoldA.HeatingZone[2].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighA[2]);

	SR_TempDeviationToHighA[3](SET1:=mxAutoMode AND
((BottomMoldA.HeatingZone[3].FB_Temperature.EngTempOut > TopMoldA.HeatingZone[3].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldA.HeatingZone[3].FB_Temperature.EngTempOut < TopMoldA.HeatingZone[3].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighA[3]);

	SR_TempDeviationToHighA[4](SET1:=mxAutoMode AND
((BottomMoldA.HeatingZone[4].FB_Temperature.EngTempOut > TopMoldA.HeatingZone[4].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldA.HeatingZone[4].FB_Temperature.EngTempOut < TopMoldA.HeatingZone[4].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighA[4]);

	SR_TempDeviationToHighA[5](SET1:=mxAutoMode AND
((BottomMoldA.HeatingZone[5].FB_Temperature.EngTempOut > TopMoldA.HeatingZone[5].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldA.HeatingZone[5].FB_Temperature.EngTempOut < TopMoldA.HeatingZone[5].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighA[5]);

	SR_TempDeviationToHighA[6](SET1:=mxAutoMode AND
((BottomMoldA.HeatingZone[6].FB_Temperature.EngTempOut > TopMoldA.HeatingZone[6].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldA.HeatingZone[6].FB_Temperature.EngTempOut < TopMoldA.HeatingZone[6].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighA[6]);



(*Red hot safety regarding heating, block movement when top temperature deviates to much from bottom temperature*)
	SR_TempDeviationToHighB[1](SET1:=mxAutoMode AND
((BottomMoldB.HeatingZone[1].FB_Temperature.EngTempOut > TopMoldB.HeatingZone[1].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldB.HeatingZone[1].FB_Temperature.EngTempOut < TopMoldB.HeatingZone[1].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighB[1]);

	SR_TempDeviationToHighB[2](SET1:=mxAutoMode AND
((BottomMoldB.HeatingZone[2].FB_Temperature.EngTempOut > TopMoldB.HeatingZone[2].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldB.HeatingZone[2].FB_Temperature.EngTempOut < TopMoldB.HeatingZone[2].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighB[2]);

	SR_TempDeviationToHighB[3](SET1:=mxAutoMode AND
((BottomMoldB.HeatingZone[3].FB_Temperature.EngTempOut > TopMoldB.HeatingZone[3].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldB.HeatingZone[3].FB_Temperature.EngTempOut < TopMoldB.HeatingZone[3].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighB[3]);

	SR_TempDeviationToHighB[4](SET1:=mxAutoMode AND
((BottomMoldB.HeatingZone[4].FB_Temperature.EngTempOut > TopMoldB.HeatingZone[4].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldB.HeatingZone[4].FB_Temperature.EngTempOut < TopMoldB.HeatingZone[4].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighB[4]);

	SR_TempDeviationToHighB[5](SET1:=mxAutoMode AND
((BottomMoldB.HeatingZone[5].FB_Temperature.EngTempOut > TopMoldB.HeatingZone[5].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldB.HeatingZone[5].FB_Temperature.EngTempOut < TopMoldB.HeatingZone[5].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighB[5]);

	SR_TempDeviationToHighB[6](SET1:=mxAutoMode AND
((BottomMoldB.HeatingZone[6].FB_Temperature.EngTempOut > TopMoldB.HeatingZone[6].FB_Temperature.EngTempOut + 40.0)  OR 
( BottomMoldB.HeatingZone[6].FB_Temperature.EngTempOut < TopMoldB.HeatingZone[6].FB_Temperature.EngTempOut - 40.0)), RESET:=mxReset, Q1=>Errors.TempDeviationToHighB[6]);


(*Red hot safetyrule Regading heating Transfermold may not move down when bottommold A or B isn't hot enough*)
ASideNotWarm :=  ((BottomMoldA.HeatingZone[1].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldA.HeatingZone[1].mxZoneActive) OR
				 ((BottomMoldA.HeatingZone[2].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldA.HeatingZone[2].mxZoneActive) OR
				 ((BottomMoldA.HeatingZone[3].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldA.HeatingZone[3].mxZoneActive) OR
				 ((BottomMoldA.HeatingZone[4].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldA.HeatingZone[4].mxZoneActive) OR
				 ((BottomMoldA.HeatingZone[5].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldA.HeatingZone[5].mxZoneActive) OR
				 ((BottomMoldA.HeatingZone[6].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldA.HeatingZone[6].mxZoneActive);
		
BSideNotWarm :=  ((BottomMoldB.HeatingZone[1].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldB.HeatingZone[1].mxZoneActive) OR
				 ((BottomMoldB.HeatingZone[2].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldB.HeatingZone[2].mxZoneActive) OR
				 ((BottomMoldB.HeatingZone[3].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldB.HeatingZone[3].mxZoneActive) OR
				 ((BottomMoldB.HeatingZone[4].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldB.HeatingZone[4].mxZoneActive) OR
				 ((BottomMoldB.HeatingZone[5].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldB.HeatingZone[5].mxZoneActive) OR
				 ((BottomMoldB.HeatingZone[6].FB_Temperature.EngTempOut < MachParameters.MinTempAlowTransferToBot) AND MachParameters.BottomMoldB.HeatingZone[6].mxZoneActive);
				
// FMEA (140 degree?)
SR_BotMoldAToCoolForTrMDown(SET1:=NOT mxCommisioningMode AND (BottomMoldA.mxCilIsIn AND ASideNotWarm AND TransferMold.mxCilIsMovingOut), Reset:=mxReset, Q1=>Errors.RH_BotMoldAToCoolForTrMDown);

SR_BotMoldBToCoolForTrMDown(Set1:= NOT mxCommisioningMode AND (BottomMoldB.mxCilIsIn AND BSideNotWarm AND TransferMold.mxCilIsMovingOut), reset:=mxReset, Q1=>Errors.RH_BotMoldBToCoolForTrMDown);
]]></ST>
      </Implementation>
    </Action>
    <Action Name="Init" Id="{bebf601a-4395-4aa3-ae13-588f23f74a94}">
      <Implementation>
        <ST><![CDATA[(*StateChange (Transition)  Signalgeneration*)
mxInitTransitionState:=(miInitState<>miInitOldstate);
(*State text*)
sInitStateText:=sInitStateTextDef[miInitState];
(*Timeout Watchdog for Statemachine*)
mxInitTimeoutEnable:=NOT (miInitState=0)  AND NOT mxReset;

InitTimeout(IN:=mxInitTimeoutEnable  , PT:=tInitStateTimeouts[miInitState] );
InitTimeOutUpFlank(CLK:=InitTimeout.Q );
miInitOldstate:=miInitState;

(*Set Errorbit when Raising edge of Timeout has been detected*)
IF InitTimeOutUpFlank.Q THEN
	exInitTimeOut:=TRUE; 			(* 1 Timeout for the whole programcycle *)
END_IF

(*Function to reset the Statemachine*)
IF mxResetInitState THEN
	mxResetInitState:=FALSE;
	miInitState:=0;
	miInitOldstate:=miInitState;
	mxInitTransitionState:=FALSE;

	mxStartInit:= FALSE;
	mxStopInit:= FALSE;
	
	TopMoldA.mxResetInitState:= TRUE;
	TopMoldB.mxResetInitState:= TRUE;
	BottomMoldA.mxResetInitState:= TRUE;
	BottomMoldB.mxResetInitState:= TRUE;
	TransferMold.mxResetInitState:= TRUE;
	ProductForming.mxResetInitState:= TRUE;
END_IF

(*Definition State has Error*)
mxInitHasError:=FALSE;

(*Init State's*)
CASE miInitState OF
	0: // Wait for initalisation start
		IF mxStartInit THEN
			mxStartInit:= FALSE;
			mxInitialized:= FALSE;
			TransferMold.M_StartInit();
			ProductForming.M_StartInit();
			miInitState:= 2;
		END_IF

	2: // Init Transfermold and product forming
		IF mxStopInit THEN
			mxStopInit:= FALSE;		
			miInitState:= 10;
		ELSIF TransferMold.mxInitialized AND ProductForming.mxInitialized THEN 
			IF MachParameters.EnableEamcSideA THEN
				TopMoldA.M_StartInit(); 
				miInitState:= 3;
			ELSIF MachParameters.EnableEamcSideB THEN
				TopMoldB.M_StartInit();
				miInitState:= 5; 
			END_IF
		END_IF
		
	3: // Initialise topmold A
		IF mxStopInit THEN
			mxStopInit:= FALSE;
			miInitState:= 10;
		ELSIF TopMoldA.mxInitialized THEN
			BottomMoldA.M_StartInit();
			miInitState:= 4;
		END_IF

	4:	// Initialise Bottommold A
		IF mxStopInit THEN
			mxStopInit:= FALSE;			
			miInitState:= 10;
		ELSIF BottomMoldA.mxInitialized THEN
			IF MachParameters.EnableEamcSideB THEN
				TopMoldB.M_StartInit();
				miInitState:= 5; 
			ELSE
				miInitState:= 7;
			END_IF
		END_IF

	5:	// Initialise Topmold B
		IF mxStopInit THEN
			mxStopInit:= FALSE;
			miInitState:= 10;
		ELSIF TopMoldB.mxInitialized THEN
			BottomMoldB.M_StartInit();
			miInitState:= 6;
		END_IF

	6: 	// Initialise BottomMold B	
		IF mxStopInit THEN
			mxStopInit:= FALSE;
			miInitState:= 10;
		ELSIF BottomMoldB.mxInitialized THEN
			miInitState:= 7;
		END_IF

	7: 	// Initialized 
		mxInitialized:= TRUE;
		miInitState:= 0;

	10:	// Stop init 
		mxInitialized:= FALSE;
		IF TopMoldA.mxInitBusy THEN TopMoldA.M_StopInit(); END_IF
		IF TopMoldB.mxInitBusy THEN TopMoldB.M_StopInit(); END_IF
		IF BottomMoldA.mxInitBusy THEN BottomMoldA.M_StopInit(); END_IF
		IF BottomMoldB.mxInitBusy THEN BottomMoldB.M_StopInit(); END_IF
		IF TransferMold.mxInitBusy THEN TransferMold.M_StopInit(); END_IF
		IF ProductForming.mxInitBusy THEN ProductForming.M_StopInit(); END_IF
		IF HydraulicsMain.mxInitbusy THEN HydraulicsMain.M_StopInit(); END_IF		
		miInitState:=11;
		
	11:	// Stop Init *)
		IF NOT TopMoldA.mxInitBusy AND NOT TopMoldB.mxInitBusy AND NOT BottomMoldA.mxInitBusy AND NOT BottomMoldB.mxInitBusy AND NOT TransferMold.mxInitBusy 
			AND NOT ProductForming.mxInitBusy AND NOT HydraulicsMain.mxInitbusy THEN
			miInitState:= 0;
		END_IF
END_CASE

mxInitBusy:= miInitState<>0;
]]></ST>
      </Implementation>
    </Action>
    <Method Name="M_StartCycle" Id="{c3ba6355-830f-4f64-92b8-b0926b73ee4f}">
      <Declaration><![CDATA[METHOD M_StartCycle
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF (NOT mxCycleBusy AND mxInitialized) OR (mxInPause AND mxInitialized) THEN
	mxStartCycle:= TRUE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StartHydraulics" Id="{03288d8b-f8cf-472e-ab5a-a5b45c757502}">
      <Declaration><![CDATA[METHOD M_StartHydraulics : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[HydraulicsMain.M_StartCycle();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StartInit" Id="{d0065209-eb3a-4b27-a51b-a49eea89f583}">
      <Declaration><![CDATA[METHOD M_StartInit
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF NOT mxInitBusy THEN 
	mxStartInit:= TRUE; 
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopCycle" Id="{edc55864-e25b-4fbd-a5ae-a10731f37f98}">
      <Declaration><![CDATA[METHOD M_StopCycle
]]></Declaration>
      <Implementation>
        <ST><![CDATA[mxStopCycle:= TRUE;	
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopCycleEmpty" Id="{2a6319e3-d535-4338-b86b-e3bceabb1bc8}">
      <Declaration><![CDATA[METHOD M_StopCycleEmpty
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF mxCycleBusy THEN 
	mxStopCycleEmpty:= TRUE; 
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopDirect" Id="{849f630c-3dec-4312-8e21-5c8187cfa2ed}">
      <Declaration><![CDATA[METHOD M_StopDirect
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF mxCycleBusy THEN
	mxStopDirect:= TRUE;	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopHydraulics" Id="{968a70db-9d0a-4ed2-afa3-4e0bfe9b47a9}">
      <Declaration><![CDATA[METHOD M_StopHydraulics
]]></Declaration>
      <Implementation>
        <ST><![CDATA[HydraulicsMain.M_StopCycleEmpty();]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_StopInit" Id="{c05d5840-e068-4039-b19c-cd8158955ab6}">
      <Declaration><![CDATA[METHOD M_StopInit
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF mxInitBusy THEN 
	mxStopInit:= TRUE; 
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Action Name="Objects" Id="{7c462a33-addc-41a0-865f-b837ce491c63}">
      <Implementation>
        <ST><![CDATA[
TopMoldA(
	mxReset:= mxReset,
	mxEmergency:= mxEmergency[8],
	mxDoorsOpened:= mxEmergency[2] OR mxEmergency[3],
	mxAutoMode:= mxAutoMode,
	mxEnableHeating:= mxEnableHeating,	
	mxTakeOutIsMovingUp:= BottomMoldA.mxTakeoutIsMovingUp, 
	ActualPositionTransfermold:=Transfermold.ActualPosition,	
	RHSR_Blocked:= Errors.RH_ToMoldAIsMovingBoMoldANotInPos,
	sgTakeOutUnitDown := BottomMoldA.sgTakeOutUnitDown,
	MachParameters:= MachParameters.TopMoldA,
	ProdParameters:= ProdParameters.TopMoldA,
	Errors=> Errors.TopMoldA);

TopMoldB(
	mxReset:= mxReset,
	mxEmergency:= mxEmergency[8],
	mxDoorsOpened:=mxEmergency[3] OR mxEmergency[4],
	mxAutoMode:= mxAutoMode,
	mxEnableHeating:= mxEnableHeating,		
	mxTakeOutIsMovingUp:= BottomMoldB.mxTakeoutIsMovingUp, 
	ActualPositionTransfermold:=Transfermold.ActualPosition,
	RHSR_Blocked := Errors.RH_ToMoldBIsMovingBoMoldBNotInPos,
	sgTakeOutUnitDown := BottomMoldB.sgTakeOutUnitDown,
	MachParameters:= MachParameters.TopMoldB,
	ProdParameters:= ProdParameters.TopMoldB,
	Errors=> Errors.TopMoldB);
	
BottomMoldA(
	mxReset:= mxReset,
	mxEmergency:=mxEmergency[8],
	mxDoorsOpened:= mxEmergency[2] OR mxEmergency[3],
	mxAutoMode:= mxAutoMode,
	mxEnableHeating:= mxEnableHeating,		
	ActualPositionTransfermold:=Transfermold.ActualPosition,
	TransferPosA:= TransferMold.TransferPosA,
	TransferPosB:= TransferMold.TransferPosB,
	ContinueWithA:=ContinueWithA,
	ContinueWithB:=ContinueWithB,
	SgElapsedDryingTime:=TopMoldA.SgElapsedDryingTime,
	SgTotalDryingTime := TopMoldA.SgTotalDryingTime,
	SgMoldsAreClosed := TopMoldA.SgTmIsDown,
	sgTopmoldBlowOffReady := TopmoldA.sgTopmoldBlowOffReady,
	sgEmptying:=mxEmptying,
	RHSR_Blocked := Errors.RH_BoMoldAIsMovingToMoldANotInPos OR Errors.RH_BoMoldAIsMovingTrMoldNotInPos OR Errors.RH_TaOutHorAIsMovingVertIsNotDown,
	mxGantryPickedUpProduct:= mxProductPickedUpGantry_A,
	MachParameters:= MachParameters.BottomMoldA,
	ProdParameters:= ProdParameters.BottomMoldA,
	SysParameters:= SysParameters.BottomMoldA,
	mxProductReadyAtTakeOut=> mxProductReadyAtTakeout_A,
	Errors=> Errors.BottomMoldA);

BottomMoldB(
	mxReset:= mxReset,
	mxEmergency:= mxEmergency[8],
	mxDoorsOpened:=mxEmergency[3] OR mxEmergency[4],
	mxAutoMode:= mxAutoMode,
	mxEnableHeating:= mxEnableHeating,
	ActualPositionTransfermold:=Transfermold.ActualPosition,
	TransferPosA:= TransferMold.TransferPosA,
	TransferPosB:= TransferMold.TransferPosB,
	ContinueWithA:=ContinueWithA,
	ContinueWithB:=ContinueWithB,
	SgElapsedDryingTime:=TopMoldB.SgElapsedDryingTime,
	SgTotalDryingTime := TopMoldB.SgTotalDryingTime,
	SgMoldsAreClosed := TopMoldB.SgTmIsDown,
	sgTopmoldBlowOffReady := TopmoldB.sgTopmoldBlowOffReady,
	sgEmptying:=mxEmptying,	
	RHSR_Blocked := Errors.RH_BoMoldBIsMovingToMoldBNotInPos OR Errors.RH_BoMoldBIsMovingTrMoldNotInPos OR Errors.RH_TaOutHorBIsMovingVertIsNotDown,
	mxGantryPickedUpProduct:= mxProductPickedUpGantry_B,
	MachParameters:= MachParameters.BottomMoldB,
	ProdParameters:= ProdParameters.BottomMoldB,
	SysParameters:= SysParameters.BottomMoldB,
	mxProductReadyAtTakeOut=> mxProductReadyAtTakeout_B,
	Errors=> Errors.BottomMoldB);

TransferMold(
	mxReset:= mxReset,
	mxEmergency:= mxEmergency[2] OR mxEmergency[3] OR mxEmergency[4] OR mxEmergency[8],
	mxAutoMode:= mxAutoMode,
	mxStartVacuum:= ProductForming.mxStartTransferMoldVacuum,
	RHSR_Blocked:= Errors.RH_TrMoldIsMovingBoMoldANotInPos OR Errors.RH_TrMoldIsMovingBoMoldBNotInPos OR Errors.RH_TrMoldIsMovingSprayBNotInPos,
	MachParameters:= MachParameters.TransferMold,
	ProdParameters:= ProdParameters.TransferMold,
	Errors=> Errors.TransferMold);

ProductForming( 
	mxReset:= mxReset,
	mxEmergency:= mxEmergency[2] OR mxEmergency[3] OR mxEmergency[4] OR mxEmergency[8],
	mxFirstCycle:= mxFirstCycle,
	mxAutoMode:= mxAutoMode,
	TransfermoldDownPosition:=TransferMold.DownPosition,
	TransfermoldMovingDown:=TransferMold.mxCilIsMovingOut,
	TransfermoldMovingUp:=Transfermold.mxCilIsMovingIn,
	TransferFormingPosOffset:= MachParameters.TransferMold.PositionStartFormingProcess,
	ActualPositionTransfermold:=TransferMold.ActualPosition,
	RHSR_Blocked := Errors.RH_SprayBIsMovingTrNotClear,
	MachParameters:= MachParameters.ProductForming,
	SysParameters:= SysParameters.ProductForming,
	NewValue_MaxTimeSingleKO := NewValue_MaxKO_Forming,
	Errors=> Errors.ProductForming);

HydraulicsMain(
	mxReset:= mxReset,
	mxEmergency:=mxEmergency[8],	// All EM buttons.
	mxDoorOpened:=mxEmergency[2] OR mxEmergency[3] OR mxEmergency[4],	// Coresponding door zones have error.
	mxAutoMode:= mxAutoMode,
	mxHydraulicsReady => mxHydraulicsReady,
	PlcCycleTime:=PlcCycleTime,
	MachineParameters:= MachParameters.HydraulicsMain,
	Errors=>Errors.HydraulicMain);
]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_InMoldDrying">
      <LineId Id="1568" Count="0" />
      <LineId Id="1570" Count="0" />
      <LineId Id="1573" Count="0" />
      <LineId Id="1949" Count="0" />
      <LineId Id="2548" Count="0" />
      <LineId Id="2550" Count="10" />
      <LineId Id="2549" Count="0" />
      <LineId Id="1765" Count="0" />
      <LineId Id="1767" Count="0" />
      <LineId Id="1770" Count="0" />
      <LineId Id="1768" Count="0" />
      <LineId Id="1771" Count="0" />
      <LineId Id="3086" Count="0" />
      <LineId Id="3316" Count="0" />
      <LineId Id="3318" Count="0" />
      <LineId Id="3320" Count="1" />
      <LineId Id="3319" Count="0" />
      <LineId Id="3317" Count="0" />
      <LineId Id="3087" Count="0" />
      <LineId Id="3322" Count="0" />
      <LineId Id="3548" Count="1" />
      <LineId Id="3094" Count="0" />
      <LineId Id="3097" Count="0" />
      <LineId Id="3093" Count="0" />
      <LineId Id="3088" Count="0" />
      <LineId Id="3090" Count="0" />
      <LineId Id="3089" Count="0" />
      <LineId Id="3085" Count="0" />
      <LineId Id="1394" Count="0" />
      <LineId Id="1177" Count="0" />
      <LineId Id="288" Count="0" />
      <LineId Id="2860" Count="0" />
      <LineId Id="289" Count="1" />
      <LineId Id="2859" Count="0" />
      <LineId Id="291" Count="0" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.Cycle">
      <LineId Id="4127" Count="34" />
      <LineId Id="4911" Count="0" />
      <LineId Id="4162" Count="2" />
      <LineId Id="4927" Count="0" />
      <LineId Id="4952" Count="1" />
      <LineId Id="4165" Count="0" />
      <LineId Id="4860" Count="1" />
      <LineId Id="4755" Count="0" />
      <LineId Id="4757" Count="0" />
      <LineId Id="4756" Count="0" />
      <LineId Id="4988" Count="1" />
      <LineId Id="4992" Count="0" />
      <LineId Id="4166" Count="5" />
      <LineId Id="4983" Count="0" />
      <LineId Id="4986" Count="0" />
      <LineId Id="4984" Count="0" />
      <LineId Id="4172" Count="8" />
      <LineId Id="4875" Count="0" />
      <LineId Id="4920" Count="4" />
      <LineId Id="4932" Count="0" />
      <LineId Id="4181" Count="7" />
      <LineId Id="4728" Count="0" />
      <LineId Id="4730" Count="0" />
      <LineId Id="4732" Count="0" />
      <LineId Id="4731" Count="0" />
      <LineId Id="4729" Count="0" />
      <LineId Id="4733" Count="2" />
      <LineId Id="4894" Count="8" />
      <LineId Id="4727" Count="0" />
      <LineId Id="4196" Count="0" />
      <LineId Id="4954" Count="1" />
      <LineId Id="4958" Count="0" />
      <LineId Id="4956" Count="1" />
      <LineId Id="4959" Count="0" />
      <LineId Id="4925" Count="0" />
      <LineId Id="4960" Count="0" />
      <LineId Id="4198" Count="2" />
      <LineId Id="4718" Count="0" />
      <LineId Id="4202" Count="12" />
      <LineId Id="4804" Count="1" />
      <LineId Id="4215" Count="9" />
      <LineId Id="4779" Count="0" />
      <LineId Id="4784" Count="0" />
      <LineId Id="4782" Count="0" />
      <LineId Id="4800" Count="0" />
      <LineId Id="4783" Count="0" />
      <LineId Id="4785" Count="1" />
      <LineId Id="4801" Count="0" />
      <LineId Id="4787" Count="0" />
      <LineId Id="4780" Count="0" />
      <LineId Id="4225" Count="3" />
      <LineId Id="4845" Count="0" />
      <LineId Id="4229" Count="0" />
      <LineId Id="4819" Count="1" />
      <LineId Id="4823" Count="1" />
      <LineId Id="4230" Count="4" />
      <LineId Id="4827" Count="0" />
      <LineId Id="4806" Count="1" />
      <LineId Id="4825" Count="0" />
      <LineId Id="4808" Count="0" />
      <LineId Id="4837" Count="0" />
      <LineId Id="4834" Count="0" />
      <LineId Id="4843" Count="0" />
      <LineId Id="4835" Count="0" />
      <LineId Id="4814" Count="0" />
      <LineId Id="4809" Count="1" />
      <LineId Id="4839" Count="0" />
      <LineId Id="4826" Count="0" />
      <LineId Id="4840" Count="0" />
      <LineId Id="4844" Count="0" />
      <LineId Id="4841" Count="1" />
      <LineId Id="4812" Count="0" />
      <LineId Id="4818" Count="0" />
      <LineId Id="4813" Count="0" />
      <LineId Id="4788" Count="0" />
      <LineId Id="4236" Count="1" />
      <LineId Id="4792" Count="1" />
      <LineId Id="4238" Count="4" />
      <LineId Id="4737" Count="2" />
      <LineId Id="4940" Count="1" />
      <LineId Id="4937" Count="0" />
      <LineId Id="4942" Count="2" />
      <LineId Id="4915" Count="0" />
      <LineId Id="4917" Count="0" />
      <LineId Id="4919" Count="0" />
      <LineId Id="4244" Count="0" />
      <LineId Id="4849" Count="0" />
      <LineId Id="4931" Count="0" />
      <LineId Id="4245" Count="1" />
      <LineId Id="4758" Count="2" />
      <LineId Id="4247" Count="11" />
      <LineId Id="4884" Count="0" />
      <LineId Id="4961" Count="1" />
      <LineId Id="4259" Count="3" />
      <LineId Id="4968" Count="5" />
      <LineId Id="4263" Count="0" />
      <LineId Id="4967" Count="0" />
      <LineId Id="4265" Count="17" />
      <LineId Id="4879" Count="1" />
      <LineId Id="4883" Count="0" />
      <LineId Id="4882" Count="0" />
      <LineId Id="4881" Count="0" />
      <LineId Id="4283" Count="26" />
      <LineId Id="4316" Count="1" />
      <LineId Id="4320" Count="15" />
      <LineId Id="4859" Count="0" />
      <LineId Id="4336" Count="6" />
      <LineId Id="4858" Count="0" />
      <LineId Id="4343" Count="6" />
      <LineId Id="4740" Count="1" />
      <LineId Id="4350" Count="17" />
      <LineId Id="4854" Count="0" />
      <LineId Id="4368" Count="39" />
      <LineId Id="4869" Count="1" />
      <LineId Id="4913" Count="0" />
      <LineId Id="4867" Count="0" />
      <LineId Id="4409" Count="9" />
      <LineId Id="4912" Count="0" />
      <LineId Id="4419" Count="46" />
      <LineId Id="4472" Count="1" />
      <LineId Id="4914" Count="0" />
      <LineId Id="4474" Count="2" />
      <LineId Id="4871" Count="3" />
      <LineId Id="4481" Count="0" />
      <LineId Id="4483" Count="0" />
      <LineId Id="4946" Count="0" />
      <LineId Id="4963" Count="0" />
      <LineId Id="4947" Count="0" />
      <LineId Id="4929" Count="0" />
      <LineId Id="4974" Count="1" />
      <LineId Id="4484" Count="1" />
      <LineId Id="4853" Count="0" />
      <LineId Id="4486" Count="2" />
      <LineId Id="4746" Count="2" />
      <LineId Id="4762" Count="0" />
      <LineId Id="4489" Count="0" />
      <LineId Id="4491" Count="0" />
      <LineId Id="4948" Count="0" />
      <LineId Id="4964" Count="0" />
      <LineId Id="4949" Count="0" />
      <LineId Id="4930" Count="0" />
      <LineId Id="4976" Count="1" />
      <LineId Id="4492" Count="1" />
      <LineId Id="4851" Count="0" />
      <LineId Id="4494" Count="2" />
      <LineId Id="4743" Count="0" />
      <LineId Id="4745" Count="0" />
      <LineId Id="4744" Count="0" />
      <LineId Id="4764" Count="0" />
      <LineId Id="4497" Count="127" />
      <LineId Id="4631" Count="22" />
      <LineId Id="5008" Count="1" />
      <LineId Id="4752" Count="0" />
      <LineId Id="4754" Count="0" />
      <LineId Id="4753" Count="0" />
      <LineId Id="4654" Count="9" />
      <LineId Id="5006" Count="1" />
      <LineId Id="4664" Count="5" />
      <LineId Id="5003" Count="0" />
      <LineId Id="5002" Count="0" />
      <LineId Id="4670" Count="0" />
      <LineId Id="5004" Count="0" />
      <LineId Id="4671" Count="3" />
      <LineId Id="5005" Count="0" />
      <LineId Id="4675" Count="1" />
      <LineId Id="5000" Count="0" />
      <LineId Id="4677" Count="1" />
      <LineId Id="4997" Count="0" />
      <LineId Id="4679" Count="2" />
      <LineId Id="5001" Count="0" />
      <LineId Id="4909" Count="0" />
      <LineId Id="4682" Count="0" />
      <LineId Id="4998" Count="0" />
      <LineId Id="4683" Count="11" />
      <LineId Id="4910" Count="0" />
      <LineId Id="4928" Count="0" />
      <LineId Id="4950" Count="1" />
      <LineId Id="4695" Count="3" />
      <LineId Id="4993" Count="0" />
      <LineId Id="4995" Count="0" />
      <LineId Id="4994" Count="0" />
      <LineId Id="4862" Count="1" />
      <LineId Id="4699" Count="7" />
      <LineId Id="4749" Count="0" />
      <LineId Id="4751" Count="0" />
      <LineId Id="4750" Count="0" />
      <LineId Id="4707" Count="7" />
      <LineId Id="4766" Count="0" />
      <LineId Id="4768" Count="1" />
      <LineId Id="4774" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.Error">
      <LineId Id="372" Count="15" />
      <LineId Id="425" Count="0" />
      <LineId Id="388" Count="1" />
      <LineId Id="438" Count="0" />
      <LineId Id="428" Count="0" />
      <LineId Id="436" Count="0" />
      <LineId Id="439" Count="0" />
      <LineId Id="437" Count="0" />
      <LineId Id="426" Count="0" />
      <LineId Id="448" Count="3" />
      <LineId Id="427" Count="0" />
      <LineId Id="390" Count="1" />
      <LineId Id="446" Count="0" />
      <LineId Id="444" Count="0" />
      <LineId Id="392" Count="1" />
      <LineId Id="447" Count="0" />
      <LineId Id="445" Count="0" />
      <LineId Id="394" Count="3" />
      <LineId Id="442" Count="0" />
      <LineId Id="398" Count="3" />
      <LineId Id="443" Count="0" />
      <LineId Id="402" Count="22" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.ErrorsTemperature">
      <LineId Id="3" Count="8" />
      <LineId Id="94" Count="0" />
      <LineId Id="13" Count="40" />
      <LineId Id="93" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="82" Count="4" />
      <LineId Id="67" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="87" Count="4" />
      <LineId Id="80" Count="1" />
      <LineId Id="58" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="56" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.Init">
      <LineId Id="32" Count="20" />
      <LineId Id="107" Count="0" />
      <LineId Id="309" Count="0" />
      <LineId Id="306" Count="1" />
      <LineId Id="300" Count="5" />
      <LineId Id="55" Count="6" />
      <LineId Id="150" Count="2" />
      <LineId Id="154" Count="0" />
      <LineId Id="77" Count="2" />
      <LineId Id="157" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="258" Count="0" />
      <LineId Id="261" Count="0" />
      <LineId Id="259" Count="0" />
      <LineId Id="159" Count="0" />
      <LineId Id="143" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="170" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="310" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="164" Count="0" />
      <LineId Id="262" Count="0" />
      <LineId Id="264" Count="1" />
      <LineId Id="166" Count="0" />
      <LineId Id="173" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="199" Count="1" />
      <LineId Id="266" Count="0" />
      <LineId Id="268" Count="1" />
      <LineId Id="201" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="240" Count="0" />
      <LineId Id="236" Count="0" />
      <LineId Id="196" Count="0" />
      <LineId Id="242" Count="0" />
      <LineId Id="222" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="228" Count="1" />
      <LineId Id="270" Count="0" />
      <LineId Id="272" Count="1" />
      <LineId Id="230" Count="0" />
      <LineId Id="232" Count="1" />
      <LineId Id="243" Count="0" />
      <LineId Id="209" Count="1" />
      <LineId Id="274" Count="0" />
      <LineId Id="276" Count="1" />
      <LineId Id="250" Count="0" />
      <LineId Id="249" Count="0" />
      <LineId Id="227" Count="0" />
      <LineId Id="245" Count="3" />
      <LineId Id="131" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="103" Count="1" />
      <LineId Id="252" Count="2" />
      <LineId Id="256" Count="0" />
      <LineId Id="291" Count="1" />
      <LineId Id="133" Count="4" />
      <LineId Id="63" Count="0" />
      <LineId Id="80" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StartCycle">
      <LineId Id="56" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StartHydraulics">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StartInit">
      <LineId Id="14" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StopCycle">
      <LineId Id="36" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StopCycleEmpty">
      <LineId Id="14" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StopDirect">
      <LineId Id="56" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StopHydraulics">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.M_StopInit">
      <LineId Id="14" Count="0" />
      <LineId Id="10" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_InMoldDrying.Objects">
      <LineId Id="262" Count="2" />
      <LineId Id="396" Count="0" />
      <LineId Id="265" Count="2" />
      <LineId Id="375" Count="0" />
      <LineId Id="269" Count="0" />
      <LineId Id="416" Count="0" />
      <LineId Id="270" Count="6" />
      <LineId Id="397" Count="0" />
      <LineId Id="277" Count="2" />
      <LineId Id="376" Count="0" />
      <LineId Id="281" Count="0" />
      <LineId Id="417" Count="0" />
      <LineId Id="282" Count="6" />
      <LineId Id="398" Count="0" />
      <LineId Id="289" Count="1" />
      <LineId Id="395" Count="0" />
      <LineId Id="389" Count="0" />
      <LineId Id="385" Count="2" />
      <LineId Id="405" Count="1" />
      <LineId Id="400" Count="0" />
      <LineId Id="414" Count="0" />
      <LineId Id="420" Count="0" />
      <LineId Id="293" Count="3" />
      <LineId Id="358" Count="0" />
      <LineId Id="297" Count="5" />
      <LineId Id="399" Count="0" />
      <LineId Id="303" Count="1" />
      <LineId Id="371" Count="0" />
      <LineId Id="390" Count="3" />
      <LineId Id="407" Count="1" />
      <LineId Id="402" Count="0" />
      <LineId Id="415" Count="0" />
      <LineId Id="421" Count="0" />
      <LineId Id="306" Count="3" />
      <LineId Id="359" Count="0" />
      <LineId Id="310" Count="7" />
      <LineId Id="319" Count="7" />
      <LineId Id="354" Count="0" />
      <LineId Id="327" Count="0" />
      <LineId Id="380" Count="2" />
      <LineId Id="410" Count="0" />
      <LineId Id="370" Count="0" />
      <LineId Id="329" Count="2" />
      <LineId Id="411" Count="0" />
      <LineId Id="332" Count="4" />
      <LineId Id="394" Count="0" />
      <LineId Id="337" Count="0" />
      <LineId Id="363" Count="0" />
      <LineId Id="356" Count="0" />
      <LineId Id="350" Count="0" />
      <LineId Id="357" Count="0" />
      <LineId Id="351" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>